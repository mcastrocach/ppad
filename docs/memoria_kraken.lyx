#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass article
\begin_preamble
\date{}
\usepackage{pythonhighlight}
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 2.5cm
\topmargin 2.5cm
\rightmargin 2.5cm
\bottommargin 3.5cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation 0bp
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard

\series bold
\size largest
Python para el análisis de datos.
 Proyecto Final (MEBDS)
\end_layout

\begin_layout Standard
\align center
Realizado por
\emph on
: Rodrigo de la Nuez Moraleda 
\emph default
y
\emph on
 Marcos Castro Cacho
\end_layout

\begin_layout Standard
\begin_inset VSpace 15bp
\end_inset


\end_layout

\begin_layout Standard
¿cómo hemos descubierto las columnas qué utiliza kraken?
\end_layout

\begin_layout Standard
¿cómo hemos descubierto los intervalos de tiempo disponibles?
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $\bullet$
\end_inset

 
\series bold
Descripción de cómo se ha afrontado el proyecto y por qué
\end_layout

\begin_layout Standard
Este proyecto se desarrolló con el objetivo de proporcionar una herramienta
 para analizar pares de divisas de la bolsa de criptomonedas Kraken.Utiliza
 la API de Kraken para obtener datos de precios en tiempo real para varios
 pares de divisas y visualiza estos datos utilizando la biblioteca plotly.Además,
 calcula indicadores de análisis técnico como el oscilador estocástico y
 su media móvil, que pueden ayudar en las decisiones de trading.El proyecto
 está escrito en Python y utiliza varias bibliotecas, como pandas para la
 manipulación de datos, plotly para la visualización de datos y krakenex
 para interactuar con la API de Kraken.También utiliza Streamlit para la
 funcionalidad de la aplicación web.El código se ha estructurado en varios
 módulos y clases para facilitar la organización y la reutilización del
 código.Por ejemplo, la clase Graph en el módulo `graphs.py` se encarga de
 crear gráficos de velas y osciladores estocásticos para el análisis de
 trading.La clase Front Front en el módulo `front.py` se encarga de manejar
 la parte frontal de la aplicación.Durante el desarrollo del proyecto, tomamos
 varias decisiones de diseño.
 Por ejemplo, elegimos usar la biblioteca plotly para la visualización de
 datos debido a su flexibilidad y potencia.
 También decidimos usar la biblioteca krakenex para interactuar con la API
 de Kraken debido a su simplicidad y facilidad de uso.
 Además, abordamos varios desafíos durante el desarrollo del proyecto, como
 la manipulación de datos en tiempo real y la visualización de datos de
 trading de manera efectiva.
\end_layout

\begin_layout Standard
En este proyecto se busca ser capaz de obtener y graficar datos actualizados
 de la cotización de un par de divisas de forma que se pueda realizar un
 análisis financiero y estudio de las tendencias del mercado.
 Este proceso ha sido llevado a cabo utilizando la plataforma Kraken, cuyo
 servicio ofrece información en tiempo real sobre precios y cotizaciones
 de diversas monedas, incluyendo criptomonedas como Bitcoin y Ethereum,
 entre otras, así como pares de divisas tradicionales.
 Con este objetivo se ha utilizado la librería 
\emph on
krakenex 
\emph default
que permite inicializar un cliente que interactúe a través de consultas
 con la propia API de la plataforma, en nuestro caso hemos tomado la información
 OHLC para un par de divisas e intervalo (unidad de minutos) seleccionado
 de entre los que la plataforma permite seleccionar.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Enumerate
- Lectura y representación del movimiento del par de monedas
\end_layout

\begin_deeper
\begin_layout Standard
Para la descarga de los datos hacemos una llamada a la API de kraken.
\end_layout

\begin_layout Standard
Para ello primero inicializamos el cliente de kraken, para hacer una llamada
 al endpoint publico OHCL.
\end_layout

\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{python}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

     def calculate_profit(self, df):        try:            coins = 0  
          total_spent = 0            df['Buy_Price'] = np.where(df['Buy_Signal'],
 df['Close'], np.nan)            df['Sell_Price'] = np.where(df['Sell_Signal'],
 df['Close'], np.nan)            for i in range(len(df)):               
 if df['Buy_Signal'].iloc[i]:                    coins += 100           
         total_spent += df['Buy_Price'].iloc[i]*100                if df['Sell_Si
gnal'].iloc[i] and coins >= 100:                    coins -= 100        
            total_spent -= df['Sell_Price'].iloc[i]*100 º           df['Profit']
 = df['Close'] * coins - total_spent            return df        except
 Exception as e:           print(f"An error occurred while creating the
 profit data: {e}")            return pd.DataFrame()
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{python}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
En la llamada hacemos uso de los siguientes argumentos:
\end_layout

\begin_layout Standard
Pair: La pareja de monedas de la que sacaremos los datos a eleccion del
 usuario.
 La lista de todas las parejas la sacamos del endpoint publico de kraken
 
\begin_inset Quotes eld
\end_inset

AssetPairs
\begin_inset Quotes erd
\end_inset

 de la siguiente manera: TODO Captura caja seleccion parejas
\begin_inset ERT
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Interval: El periodo de tiempo del que sacamos los datos, a elección del
 usuario tambien, ofrecemos los intervalos de tiempo mas comunes.
 Entre un minuto a dos semanas, tambien damos la posibilidad de introducir
 un intervalo personalizado, en minutos.
 TODO Captura seleccion agregaciones
\end_layout

\begin_layout Standard
Si el intervalo introducido es personalizado, TODO explicar agregaciones
\begin_inset ERT
status open

\begin_layout Plain Layout

  # This function aggregates data into custom time intervals that are not
 natively provided by the API     def aggregate_intervals(self, df):   
      # Resamples the DataFrame to the specified interval and aggregates
 key metrics         resampled_df = df.resample(f'{self.interval}T').agg({
 'Open': 'first',                                                      
          'High': 'max',                                               
                 'Low': 'min',                                         
                       'Close': 'last',                                
                                'Volume': 'sum'})         return resampled_df
 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Since: El punto de partida para los datos, el punto final se determina por
 el intervalo.
 TODO captura del selector de fecha
\end_layout

\begin_layout Standard
Acto seguido limpiamos los datos con el siguiente codigo:
\begin_inset ERT
status open

\begin_layout Plain Layout

  ohlc_data = response['result'][self.pair]  # Extract OHLC data from API
 response
\end_layout

\begin_layout Plain Layout

            # Convert OHLC data to a DataFrame and remove unnecessary columns
             ohlc_df = pd.DataFrame(ohlc_data, columns=["timestamp", "Open",
 "High", "Low", "Close", "NaN", "Volume", "MaM"]).drop(['NaN', 'MaM'], axis=1)
\end_layout

\begin_layout Plain Layout

            # Convert timestamps to datetime format and set as DataFrame
 index             ohlc_df["timestamp"] = pd.to_datetime(ohlc_df["timestamp"],
 unit='s')    # Unix timestamp to Python datetime             ohlc_df.set_index(p
d.DatetimeIndex(ohlc_df["timestamp"]), inplace=True)
\end_layout

\begin_layout Plain Layout

            # Convert all price and volume data to float type for calculations
             ohlc_df["Open"] = ohlc_df["Open"].astype(float)       # Opening
 price of a financial instrument for the given period             ohlc_df["High"
] = ohlc_df["High"].astype(float)       # Highest price of the instrument
 in the given period             ohlc_df["Low"] = ohlc_df["Low"].astype(float)
         # Lowest price of the instrument in the given period          
   ohlc_df["Close"] = ohlc_df["Close"].astype(float)     # Closing price
 of the instrument for the given period             ohlc_df["Volume"] =
 ohlc_df["Volume"].astype(float)   # Volume of transactions occurred in the
 given period
\end_layout

\begin_layout Plain Layout

            # Add Simple Moving Average (SMA) and Exponential Moving Average
 (EMA) to the DataFrame             window = 14 if ohlc_df.shape[0] >= 60
 else 3  # Determine window size based on data points             ohlc_df['SMA']
 = ohlc_df['Close'].rolling(window=window).mean()             ohlc_df['EMA']
 = ohlc_df['Close'].ewm(span=window, adjust=False).mean()
\end_layout

\begin_layout Plain Layout

            # Aggregate data into custom intervals if needed           
  if self.interval not in (1, 5, 15, 30, 60, 240, 1440, 10080, 21600):  
               ohlc_df = self.aggregate_intervals(ohlc_df)             return
 ohlc_df  # Return the prepared DataFrame
\end_layout

\end_inset

Los datos los convertimos en un DataFrame de pandas para su posterior manipulaci
ón.
 Este DataFrame contiene las columnas, precios de apertura, cierre, alto
 y bajo, así como para el volumen de transacciones para cada intervalo de
 tiempo.
 
\end_layout

\end_deeper
\begin_layout Enumerate
- Graficar cotizaciones.
\end_layout

\begin_deeper
\begin_layout Enumerate
TODO,descripcion, referenciar codigo y añadir capturas
\end_layout

\begin_deeper
\begin_layout Enumerate
Despues de seleccionar los datos para graficar, le damos al usuario 3 opciones
\end_layout

\begin_deeper
\begin_layout Enumerate
Graficar las velas con OHCL:
\end_layout

\begin_deeper
\begin_layout Standard
Creamos una figura candlestick de plotly y le pasamos los datos de OHCL.
 Adicionalmente añadimos un scatter de 'Simple moving average' y 'Exponential
 moving average' TODO explicacion adicional de los indicadores
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

    @staticmethod  # Static method to create a candlestick chart from OHLC
 data using Plotly     def candlestick(ohlc_df):         try:          
   # Use the last 60 data points from the OHLC DataFrame for the chart 
            df = ohlc_df[-60:]
\end_layout

\begin_layout Plain Layout

            # Define the candlestick chart components and moving averages
             data = [ go.Candlestick(x=df.index, open=df['Open'], high=df['High'],
                                    low=df['Low'], close=df['Close'], name='Cand
lestick Data'),
\end_layout

\begin_layout Plain Layout

                     go.Scatter(x=df.index, y=df['SMA'], name='Simple Moving
 Average'),                      go.Scatter(x=df.index, y=df['EMA'], name='Exponen
tial Moving Average') ]
\end_layout

\begin_layout Plain Layout

            # Define the layout for the plotly figure, setting titles and
 axis labels.
             layout = go.Layout(title='Candlestick Graph with Moving Average',
                                yaxis=dict(title='Price'))  # Label for
 the y-axis
\end_layout

\begin_layout Plain Layout

            fig = go.Figure(data=data, layout=layout)  # create a Figure
 object with the OHLC data             return fig  # return the Figure object
 for plotting                  except Exception as e:             # Handle
 exceptions in chart creation and return an empty figure in case of an error
             print(f"An error occurred while creating the candlestick chart:
 {e}")             return go.Figure()  # Return an empty Plotly Figure object
 if an error occurs 
\end_layout

\end_inset

TODO captura de candlestick
\end_layout

\end_deeper
\begin_layout Enumerate
Graficar el estocástico y la media móvil
\end_layout

\begin_deeper
\begin_layout Standard
El estocástico es un indicador de momentum desarrollado en los años 50.Se
 utiliza para mostrar la ubicación del cierre actual en relación con el
 rango alto/bajo durante un número determinado de períodos.La fórmula para
 calcular el estocástico es la siguiente:
\begin_inset Formula %K=(Preciodecierreactual-Mínimomásbajo)/(Máximomásalto-Mínimomásbajo)*100

\end_inset

Donde:- Precio de cierre actual: es el último precio al que se negoció un
 activo.- Mínimo más bajo: es el precio más bajo negociado del activo durante
 un período determinado.- Máximo más alto: es el precio más alto negociado
 del activo durante un período determinado.El estocástico se representa con
 dos líneas, %K y %D.
 La línea %D es una media móvil de %K.Cuando la línea %K cruza por encima
 de la línea %D, se genera una señal de compra.
 Cuando la línea %K cruza por debajo de la línea %D, se genera una señal
 de venta.
 TODO comprimir este parrafo a una o dos frases o borrar directamente
\end_layout

\begin_layout Standard
Explicación de nuestra forma de calcularlo: Primero, calcula el oscilador
 estocástico (%K) y su media móvil (%D) utilizando los precios de cierre,
 alto y bajo de un DataFrame de pandas.
 Luego, genera señales de compra y venta basadas en las condiciones especificada
s en las líneas 117 y 118.
\end_layout

\begin_layout Standard
La fórmula (df['Close'] - df['L14']) / (df['H14'] - df['L14']) * 100 es
 la implementación de la fórmula del oscilador estocásticoque mide la relación
 entre el precio de cierre actual y el rango de precios en un número determinado
 de períodos.
\end_layout

\begin_layout Standard
La línea df['%D'] = df['%K'].rolling(window=3).mean() calcula la media móvil
 de 3 períodos de %K, que se conoce como %D.
 La media móvil se utiliza para suavizar las fluctuaciones de %K y generar
 una línea de señal para las señales de compra y venta.
\end_layout

\begin_layout Standard
Tambien generamos las señales de compra y venta que utilizaremos en la simulacio
n de beneficios.
\end_layout

\begin_layout Itemize
Las de compra se generan cuando la línea %K cruza por encima de la línea
 %D y el valor de %D es menor que 20
\end_layout

\begin_layout Itemize
Las de venta se generan cuando la línea %K cruza por debajo de la línea
 %D y el valor de %D es mayor que 80
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

    @staticmethod  # Calculate and graph the stochastic oscillator and its
 mobile mean      def stochastic(df):         try:             window =
 14 if df.shape[0]>=60 else 3             df['L14'] = df['Low'].rolling(window=win
dow).min()             df['H14'] = df['High'].rolling(window=window).max()
             df['%K'] = (df['Close'] - df['L14']) / (df['H14'] - df['L14'])
 * 100             df['%D'] = df['%K'].rolling(window=3).mean()          
   df['Buy_Signal'] = ((df['%K'] > df['%D']) & (df['%K'].shift(1) < df['%D'].shift
(1))) & (df['%D'] < 20)             df['Sell_Signal'] = ((df['%K'] < df['%D'])
 & (df['%K'].shift(1) > df['%D'].shift(1))) & (df['%D'] > 80)            
 df = df[-60:]
\end_layout

\begin_layout Plain Layout

            data = [# The first plot is a line chart for the '%K' line of
 the stochastic oscillator                     go.Scatter(x=df.index, y=df['%K'],
 name='Stochastic Oscillator'),
\end_layout

\begin_layout Plain Layout

                    # The second plot is a line chart for the '%D' line
 of the stochastic oscillator                     go.Scatter(x=df.index, y=df['%D'
], name='Smoothed Stochastic Oscillator')]
\end_layout

\begin_layout Plain Layout

            # Define the layout for the plotly figure, setting titles and
 axis labels.
             layout = go.Layout(title='Stochastic Oscillator with its Smoothed
 Version',                                yaxis=dict(title='Value (%)',
 range=[0,100]))  # Label for the y-axis
\end_layout

\begin_layout Plain Layout

            fig = go.Figure(data=data, layout=layout)  # create a Figure
 object with the candlestick data             return fig  # return the Figure
 object for plotting
\end_layout

\begin_layout Plain Layout

        except Exception as e:             print(f"An error occurred while
 creating the candlestick chart: {e}")             return go.Figure()
\end_layout

\end_inset

TODO captura o capturas del K y D
\end_layout

\begin_layout Enumerate
Graficar los dos juntos
\end_layout

\begin_deeper
\begin_layout Standard
Finalmente damos al usuario la opción de graficar las anteriores opciones
 juntas.
 TODO captura graficas juntas
\end_layout

\begin_layout Standard
Adicionalmente aqui damos la opcion de simular ganancias que sera explicada
 en su seccion mas adelante TODO Es esta linea necesaria?
\end_layout

\end_deeper
\end_deeper
\begin_layout Enumerate
Media movil exponencial
\end_layout

\begin_deeper
\begin_layout Standard
Es otro tipo de media movil que da mas peso a los datos mas recientes, lo
 que hace que sea mas sensibles a cambios a corto plazo.
 TODO confirmame que esto es correcto?
\end_layout

\end_deeper
\begin_layout Enumerate
Media movil media
\end_layout

\begin_deeper
\begin_layout Standard
TODO tenemos esto siquiera?, no es el smoothed stochastic oscilator?
\end_layout

\end_deeper
\begin_layout Enumerate
Calculadora de ganancias
\end_layout

\begin_deeper
\begin_layout Standard
Damos tambien la opción de hacer una pequeña simulación utilizando los datos
 que vemos en las graficas.
 Para ello cogemos las señales de compra y simulamos una cartera en la que
 compramos 100 unidades de la moneda por señal y vendemos 100 unidades por
 cada señal de venta.
 La grafica representa las ganancias o perdidas que se tendrian en el periodo.
\end_layout

\begin_layout Standard
No se muestra ninguna grafica si no se han generado señales de compra en
 el periodo.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

    def calculate_profit(self, df):         try:             coins = 0 
            total_spent = 0             df['Buy_Price'] = np.where(df['Buy_Signal
'], df['Close'], np.nan)             df['Sell_Price'] = np.where(df['Sell_Signal']
, df['Close'], np.nan)             for i in range(len(df)):             
    if df['Buy_Signal'].iloc[i]:                     coins += 100       
              total_spent += df['Buy_Price'].iloc[i]*100                
 if df['Sell_Signal'].iloc[i] and coins >= 100:                     coins
 -= 100                     total_spent -= df['Sell_Price'].iloc[i]*100 
            df['Profit'] = df['Close'] * coins - total_spent           
  return df         except Exception as e:             print(f"An error
 occurred while creating the profit data: {e}")             return pd.DataFrame()
\end_layout

\begin_layout Plain Layout

    def profit_graph(self, df):         try:             df = df[-60:] 
            if not df['Buy_Signal'].any():  # Check if there are any buy
 signals                 return None  # Return None if no buy signals  
           first_buy_signal = df[df['Buy_Signal']].index[0]  # Get the index
 of the first buy signal             df = df.loc[first_buy_signal:]  # Slice
 the DataFrame from the first buy signal onwards             data = [go.Scatter(x
=df.index, y=df['Profit'].cumsum(), name='Profit'),                     go.Scatter(
x=df[df['Buy_Signal']].index, y=df[df['Buy_Signal']]['Profit'].cumsum(), mode='mar
kers', marker=dict(color='green', size=10), name='Buy Signal'),        
             go.Scatter(x=df[df['Sell_Signal']].index, y=df[df['Sell_Signal']]['Pr
ofit'].cumsum(), mode='markers', marker=dict(color='red', size=10), name='Sell
 Signal')]             layout = go.Layout(title='Profit',               
          xaxis=dict(title='Time'),   # label for the x-axis           
               yaxis=dict(title='Value'))  # Label for the y-axis      
       fig = go.Figure(data=data, layout=layout)  # create a Figure object
 with the profit data             return fig  # return the Figure object
 for plotting         except Exception as e:             print(f"An error
 occurred while creating the profit chart: {e}")             return go.Figure()
\end_layout

\end_inset

TODO Captura de la grafica de beneficios
\end_layout

\end_deeper
\end_deeper
\begin_layout Enumerate
Estructura
\end_layout

\begin_deeper
\begin_layout Enumerate
Funciones y utilizacion de clases:
\end_layout

\begin_deeper
\begin_layout Standard
El proyecto se estructura en varios módulos y clases para facilitar la organizac
ión y la reutilización del código.
\end_layout

\begin_layout Standard
El módulo principal del proyecto es main.py, que importa y utiliza las funciones
 y clases definidas en otros módulos.
\end_layout

\begin_layout Standard
Los módulos adicionales incluyen graphs.py y front.py.
\end_layout

\begin_layout Standard
- graphs.py contiene la clase Graph que se encarga de crear gráficos de velas
 y osciladores estocásticos para el análisis de trading.
\end_layout

\begin_layout Standard
- front.py contiene la clase Front que se encarga de manejar la interfaz
 de usuario de la aplicación.
\end_layout

\begin_layout Standard
Además, el proyecto incluye un archivo README.md que proporciona una descripción
 general del proyecto y las instrucciones para su uso.
 También se incluye una carpeta docs que contiene varios archivos de texto
 que proporcionan más detalles sobre el proyecto y sus requisitos.
\end_layout

\end_deeper
\begin_layout Enumerate
Manejo de errores y excepciones
\end_layout

\begin_deeper
\begin_layout Standard
El manejo de excepciones en este proyecto se realiza principalmente a través
 de la estructura de control de flujo try/except.
 Esta estructura permite capturar y manejar errores que pueden ocurrir durante
 la ejecución del programa.
\end_layout

\begin_layout Standard
Por ejemplo en el metodo que genera la grafica de beneficios, en caso de
 encontrar un error imprime un mensaje por consola y retorna una figura
 vacia.
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

    def profit_graph(self, df):         try: 			[...]             fig = go.Figure(da
ta=data, layout=layout)  # create a Figure object with the profit data 
            return fig  # return the Figure object for plotting        
 except Exception as e:             print(f"An error occurred while creating
 the profit chart: {e}")             return go.Figure()
\end_layout

\end_inset


\end_layout

\begin_layout Standard
En esta ocasion por ejemplo imprimimos un mensaje de error directamente
 en la aplicación.
\begin_inset ERT
status open

\begin_layout Plain Layout

    # Method to execute the core operations of the Streamlit application
     def run(self):         try: 			[...]         except Exception as e:  
           # Handle and display any exceptions that occur during execution
             st.error(f"An error occurred: {e}")  # Show the error message
 to the user in the app
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Puntuación extra
\end_layout

\begin_deeper
\begin_layout Enumerate
Testeo y cobertura (unit-testing, integration-testing)
\end_layout

\begin_deeper
\begin_layout Standard
Hemos gestionado los unit-test e intrgration tests con la libreria unittest.
 Este módulo permite definir clases de prueba con métodos que representan
 pruebas individuales.
 Aquí vemos un ejemplo de los tests que hemos añadido al proyecto.
 TODO poner algo mas aqui?
\begin_inset ERT
status open

\begin_layout Plain Layout

 # Test method to test the get_kraken_pairs function     def test_get_kraken_pai
rs(self):         result = get_kraken_pairs()  # Calling the get_kraken_pairs
 function and storing its result                  # Checking if the result
 is a tuple and has a length greater than 0         self.assertIsInstance(result,
 tuple)         self.assertTrue(len(result) > 0)
\end_layout

\end_inset

TODO Pideme un a captura de los tests pasando
\end_layout

\end_deeper
\begin_layout Enumerate
Facilitar los mecanismos para la reproducción del entorno virtual (ya sea
 con Poetry, Pipenv o pip)
\end_layout

\begin_deeper
\begin_layout Enumerate
Para añadir Poetry al proyecto, se ha utilizado el archivo pyproject.toml
 que se encuentra en la raíz del proyecto.
 Este archivo es utilizado por Poetry para manejar las dependencias del
 proyecto.
 En este archivo se especifican las dependencias del proyecto, la versión
 de Python requerida y otros metadatos del proyecto.
\begin_inset ERT
status open

\begin_layout Plain Layout

[tool.poetry] name = "krakenpythonmarcosrodrigo" version = "0.1.0" description
 = "A streamlit tool for rendering kraken data" authors = ["Your Name <you@examp
le.com>"] readme = "README.md"
\end_layout

\begin_layout Plain Layout

[tool.poetry.dependencies] python = "^3.11" plotly = "4.14.3" streamlit = "0.79.0"
 coverage = "5.5" pandas = "2.1.4" numpy = "1.26.2" krakenex = "2.1.0" streamlit-option
-menu = "0.3.6"
\end_layout

\begin_layout Plain Layout

[build-system] requires = ["poetry-core"] build-backend = "poetry.core.masonry.api"
\end_layout

\end_inset

Para reproducir el entorno virtual utilizando Poetry, se deben seguir los
 siguientes pasos:
\end_layout

\begin_deeper
\begin_layout Standard
1.
 Instalar Poetry.
 Puedes hacerlo siguiendo las instrucciones en la documentación oficial
 de Poetry.
\end_layout

\begin_layout Standard
2.
 Clonar el repositorio del proyecto.
\end_layout

\begin_layout Standard
3.
 Navegar hasta el directorio del proyecto.
\end_layout

\begin_layout Standard
4.
 Ejecutar el comando 
\begin_inset ERT
status open

\begin_layout Plain Layout

Poetry install
\end_layout

\end_inset

 Este comando instalará todas las dependencias especificadas en el archivo
 pyproject.toml.
\end_layout

\begin_layout Standard
5.
 Para activar el entorno virtual creado por Poetry, ejecuta el comando poetry
 shell.
 
\end_layout

\end_deeper
\end_deeper
\begin_layout Enumerate
Distribucion del proyecto a traves de Pypi o una plataforma PaaS( (AWS,
 Heroku, etc)
\end_layout

\begin_deeper
\begin_layout Enumerate
Estos son los pasos seguidos para publicar el proyecto como paquete de PyPI:
 
\end_layout

\begin_layout Standard
Primero se han instalado las dependencias de desarrollo Hatch y Twine
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

$pip install hatch 
\end_layout

\begin_layout Plain Layout

$pip install pip twine
\end_layout

\end_inset


\end_layout

\begin_layout Standard
2.
 Crear una cuenta en PyPI, adicionalmente se necesitara activar la autenticancio
n de doble factor y se debe utilizar la token de la api en twine
\end_layout

\begin_layout Standard
3.
 Para crear el distribuible: 
\begin_inset ERT
status open

\begin_layout Plain Layout

$hatch build
\end_layout

\end_inset


\end_layout

\begin_layout Standard
4.
 Para publicar el paquete:
\begin_inset ERT
status open

\begin_layout Plain Layout

$twine upload dist/* 
\end_layout

\end_inset

(con tu cuenta de pypi)
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Formula $\bullet$
\end_inset

 
\series bold
Descripción de la estructura del código y estructura de ficheros
\end_layout

\begin_layout Standard
La estructura del código y de los archivos del proyecto se organiza de la
 siguiente manera:El código principal del proyecto se encuentra en el archivo
 main.py, que importa y utiliza las funciones y clases definidas en otros
 módulos.
 Estos módulos incluyen graphs.py, que contiene la clase Graph para la creación
 de gráficos de velas y osciladores estocásticos, y front.py, que contiene
 la clase Front para manejar la interfaz de usuario de la aplicación.Además,
 el proyecto incluye un archivo README.md que proporciona una descripción
 general del proyecto y las instrucciones para su uso.
 También se incluye una carpeta docs que contiene varios archivos de texto
 que proporcionan más detalles sobre el proyecto y sus requisitos.
 En particular, el archivo enunciado.txt contiene los detalles del enunciado
 del proyecto, y los archivos memoria_kraken.lyx y memoria_kraken.lyx~ contienen
 la memoria del proyecto.Finalmente, el archivo to_do.txt contiene una lista
 de tareas pendientes para el proyecto.Durante el desarrollo del proyecto,
 se tomaron varias decisiones de diseño.
 Por ejemplo, se eligió usar la biblioteca plotly para la visualización
 de datos debido a su flexibilidad y potencia.
 También se decidió usar la biblioteca krakenex para interactuar con la
 API de Kraken debido a su simplicidad y facilidad de uso.
 Además, se abordaron varios desafíos durante el desarrollo del proyecto,
 como la manipulación de datos en tiempo real y la visualización de datos
 de trading de manera efectiva.Para la descarga de datos, primero se obtiene
 la nomenclatura que utiliza la plataforma para almacenar la información
 de los distintos pares de divisas.
 Mediante la librería requests se hace webscraping y se obtienen todos los
 pares disponibles para que el usuario pueda seleccionar el par de divisas
 que desee observar.
 Además, se da la opción de seleccionar un intervalo de tiempo (en minutos)
 de hasta un mes para que se muestre la información agregada según dicho
 intervalo.
 Con esta información se hace una consulta a la API de Kraken teniendo en
 cuenta los intervalos que permite seleccionar.
\end_layout

\begin_layout Standard
\begin_inset Formula $\bullet$
\end_inset

 
\series bold
Descripción de la forma de ejecución del código
\end_layout

\begin_layout Standard
\begin_inset Formula $\bullet$
\end_inset

 
\series bold
Pantallazos de todo Aquel punto que requiera algún tipo de visualización
\end_layout

\begin_layout Standard
————
\end_layout

\begin_layout Standard

\series bold
1.
 Lectura y representación del movimiento del par de monedas 
\end_layout

\begin_layout Standard
\begin_inset Formula $\bullet$
\end_inset

 
\series bold
Descargar datos, utilizando la librería Kraken
\end_layout

\begin_layout Standard
Para la descarga de datos primero obtenemos la nomenclatura que utiliza
 la plataforma para almacenar la información de los distintos pares de divisas,
 de forma que mediante la librería requests hacemos sacamos todos los pares
 disponibles de forma que el usuario pueda seleccionar el par de divisas
 que desee observar.
 Además, se da la opción de seleccionar un intervalo de tiempo (en minutos)
 de hasta un mes para que se muestre la información agregada según dicho
 intervalo.
 Con esta información hacemos una consulta a la API de Kraken teniendo en
 cuenta los intervalos que permite seleccionar en los dos siguientes escenarios:
\end_layout

\begin_layout Standard
- 1ª opción: el intervalo seleccionado se encuentra entre los disponibles
 (<mencionar cuáles son>) y, por tanto, con una consulta directa se pueden
 obtener los datos deseados para poder transformarlos a un dataframe de
 pandas y manipularlos para crear un índice temporal acorde al intervalo
 seleccionado y transformar los tipos necesarios
\end_layout

\begin_layout Standard
- 2ª opción: el intervalo seleccionado no se encuentra entre los disponibles,
 en tal caso calculamos el máximo divisor de entre los posibles para que
 al realizar la agregación el coste computacional sea el menor posible.
 Utilizamos los datos como en el caso anterior tomando como intervalo selecciona
do el divisor y usando una función de agregación para transformarlos al
 nuevo intervalo que queremos mostrar en la aplicación creada.
\end_layout

\begin_layout Standard
\begin_inset Formula $\bullet$
\end_inset

 
\series bold
Graficar cotizaciones.
 Graficar el par ETH/USDT.
 Input de usuario que permita graficar cualquier cotización a una a elegir
 en el menú.
\begin_inset Newline newline
\end_inset


\series default
En una primera instancia realizamos pruebas con el par ETH/USD a través
 de las librerías matplotlib y mplfinance para realizar gráficos de velas
 y de líneas con el oscilador estocástico y la media móvil pero finalmente
 utilizamos plotly.graph_objs para este objetivo.
\end_layout

\begin_layout Standard
<Insertar imágenes de los gráficos con ETH/USD y otro par a seleccionar,
 yo propongo bitcoin-libra esterlina>
\end_layout

\begin_layout Standard
RESUMEN PUBLICAR PYPI
\end_layout

\begin_layout Standard
pip install hatch 
\end_layout

\begin_layout Standard
pip install pip twine
\end_layout

\begin_layout Standard
Crear cuenta de pypi, activar 2fa y usar api token
\end_layout

\begin_layout Standard
hatch build
\end_layout

\begin_layout Standard
twine upload dist/* (con tu cuenta de pypi)
\end_layout

\end_body
\end_document
