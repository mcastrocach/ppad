#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass article
\begin_preamble
\date{}

% Default fixed font does not support bold face
\DeclareFixedFont{\ttb}{T1}{txtt}{bx}{n}{10} % for bold
\DeclareFixedFont{\ttm}{T1}{txtt}{m}{n}{10}  % for normal

% Custom colors
\usepackage{color}
\definecolor{deepblue}{rgb}{0,0,0.5}
\definecolor{deepred}{rgb}{0.6,0,0}
\definecolor{deepgreen}{rgb}{0,0.5,0}

\usepackage{listings}

% Python style for highlighting
\newcommand\pythonstyle{\lstset{
language=Python,
basicstyle=\ttm,
morekeywords={self},              % Add keywords here
keywordstyle=\ttb\color{deepblue},
emph={MyClass,__init__},          % Custom highlighting
emphstyle=\ttb\color{deepred},    % Custom highlighting style
stringstyle=\color{deepgreen},
frame=tb,                         % Any extra options here
showstringspaces=false
}}


% Python environment
\lstnewenvironment{python}[1][]
{
\pythonstyle
\lstset{#1}
}
{}

% Python for external files
\newcommand\pythonexternal[2][]{{
\pythonstyle
\lstinputlisting[#1]{#2}}}

% Python for inline
\newcommand\pythoninline[1]{{\pythonstyle\lstinline!#1!}}
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 2.5cm
\topmargin 3cm
\rightmargin 2.5cm
\bottommargin 3cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation 0bp
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard

\series bold
\size largest
Python para el Análisis de Datos.
 Proyecto Final (MEBDS)
\end_layout

\begin_layout Standard
\align center
Realizado por
\emph on
: Rodrigo de la Nuez Moraleda 
\emph default
y
\emph on
 Marcos Castro Cacho
\end_layout

\begin_layout Standard
\begin_inset VSpace 15bp
\end_inset


\end_layout

\begin_layout Standard

\series bold
\color teal
Descripción de 
\bar under
cómo
\bar default
 se ha afrontado el proyecto y 
\bar under
por qué
\bar default
.
\end_layout

\begin_layout Standard
Este proyecto ha sido llevado a cabo con el objetivo de aplicar y profundizar
 en los conocimientos adquiridos en la asignatura 
\shape italic
Python para el Análisis de Datos
\shape default
.
 Combinando el aprendizaje académico con nuestra propia investigación de
 librerías y herramientas externas, hemos creado una aplicación que permite
 analizar datos reales y actualizados de los precios de distintos de pares
 de divisas.
\begin_inset Newline newline
\end_inset

 
\end_layout

\begin_layout Standard
Para ello se ha creado una interfaz interactiva que permite crear un gráfico
 de velas junto con varios indicadores bursátiles a partir de la información
 OHLC de un par de divisas específico, el intervalo de tiempo usado para
 la agregación y, opcionalmente, un marco temporal que acote los resultados.
 
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
El proceso que se ha seguido para afrontar el proyecto y llevar a cabo el
 desarrollo del programa creado se puede dividir en varias fases.
 En primer lugar, estudiamos los datos devueltos por la API de Kraken para
 el par ETH/USDT con el objetivo de comprender la estructura de los mismos,
 así como la mejor manera de manipularlos para lograr nuestros objetivos.
 Tras ello, utilizamos webscraping para obtener todos los pares de divisas
 disponibles en la API y tener capacidad de elección entre estas opciones.
 
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Para la representación gráfica de la cotización de las divisas y los indicadores
 calculados, se hicieron pruebas con distintas librerías (
\family typewriter
matplotlib
\family default
, 
\family typewriter
mplfinance
\family default
) pero finalmente optamos por utilizar 
\family typewriter
plotly
\family default
 para ello.
 Por último, estudiamos como utilizar 
\family typewriter
streamlit
\family default
 para ofrecer al usuario una experiencia interactiva.
 Tras este punto centramos nuestros esfuerzos en refinar nuestro código
 (añadir nuevas funcionalidades, mejorar el proceso y la estructura, comentar
 su funcionamiento, etc.), agregar pruebas que nos permitan evaluar la corrección
 de nuestro programa, estudiar la reproducción de nuestro entorno a través
 de distintas herramientas y la documentación de todo el proceso en esta
 memoria.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard

\series bold
\color teal
Descripción de la 
\bar under
estructura del código
\bar default
 y 
\bar under
estructura de ficheros
\bar default
.
\end_layout

\begin_layout Standard
Nuestro programa necesita de tres ficheros distintos para su correcta ejecución:
\end_layout

\begin_layout Itemize

\family typewriter
graphs.py
\family default
, contiene la clase Graph con métodos para la obtención de los datos y la
 representación gráfica de los mismos (junto con los indicadores asociados)
 según el par de divisas, el intervalo de agregación y el marco temporal
 seleccionados.
\end_layout

\begin_layout Itemize

\family typewriter
front.py
\family default
, contiene la clase Front que crea la interaz de usuario con la que se puede
 interactuar de forma que la información mostrada coincida con la seleccionada,
 haciendo uso de los widgets y botones que 
\family typewriter
streamlit
\family default
 proporciona para la rápida y fácil creación de aplicaciones web.
\end_layout

\begin_layout Itemize

\family typewriter
main.py
\family default
, contiene el código necesario para la ejecución de la aplicación.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Estos ficheros deben encontrarse en el mismo directorio para que el programa
 pueda acceder a las distintas funcionalidades que han sido creadas sin
 la aparición de excepciones.
 Contamos además con un fichero 
\family typewriter
tests.py
\family default
 para la ejecución de las pruebas de software creadas, un fichero 
\family typewriter
requirements.txt
\family default
 para poder instalar fácilmente todas las librerías necesarias con las versiones
 adecuadas para la ejecución del código, un fichero 
\family typewriter
setup.py
\family default
 
\series bold
\color violet
(añadir descripción)
\series default
\color inherit
 y un fichero 
\family typewriter
dockerfile
\family default
 
\series bold
\color violet
(añadir descripción)
\series default
\color inherit
.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard

\series bold
\color teal
Descripción de la 
\bar under
forma de ejecución del código
\bar default
.
\end_layout

\begin_layout Standard
El comando 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
pythoninline{streamlit run main.py}
\end_layout

\end_inset

 permite la ejecución del programa desde su directorio.
\end_layout

\begin_layout Section
Lectura y representación del movimiento del par de monedas
\end_layout

\begin_layout Standard

\series bold
\color violet
(añadir descripción)
\end_layout

\begin_layout Subsection
Descarga de los datos
\end_layout

\begin_layout Standard
Para la descarga de los datos contábamos con las siguientes posibilidades:
 utilizar la librería 
\family typewriter
krakenex
\family default
, hacer una descarga directa a través de 
\family typewriter
pandas
\family default
 o descargar directamente el 
\family typewriter
.csv
\family default
 y utilizar el archivo de forma local.
 
\end_layout

\begin_layout Standard
Debido a que de estas tres opciones la única que permite recoger información
 de distintos pares de divisas para crear una herramienta interactiva es
 la primera de ellas, nuestro programa lleva a cabo esta fase del proceso
 a través de una consulta a la API de Kraken usando la librería 
\family typewriter
krakenex
\family default
.
\begin_inset Newline newline
\end_inset

 
\end_layout

\begin_layout Standard
En la 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
pythoninline{class Graph}
\end_layout

\end_inset

 del fichero 
\family typewriter
graphs.py
\family default
, inicializamos el cliente de Kraken para hacer una llamada al endpoint
 publico OHLC con la función 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
pythoninline{def obtain_data(self)}
\end_layout

\end_inset

 y almacenamos en un dataframe de 
\family typewriter
pandas
\family default
 toda la información recogida en la consulta para la selección escogida
 por el usuario.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{python}
\end_layout

\begin_layout Plain Layout

# Retrieves trading data from the Kraken API and stores it into a Pandas
 DataFrame
\end_layout

\begin_layout Plain Layout

def obtain_data(self):
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    # Initializing a Kraken API client and querying data within a try-except
 block
\end_layout

\begin_layout Plain Layout

    try:             
\end_layout

\begin_layout Plain Layout

        k = krakenex.API()  # Initialize the Kraken client              
            
\end_layout

\begin_layout Plain Layout

        # Query for OHLC data for the specified currency pair and interval
             
\end_layout

\begin_layout Plain Layout

        response = k.query_public('OHLC', {'pair':self.pair, 
\end_layout

\begin_layout Plain Layout

                                           'interval':self.interval, 
\end_layout

\begin_layout Plain Layout

                                           'since':self.since-14*self.interval*60}
)
\end_layout

\begin_layout Plain Layout

        # Check and raise an exception if errors exist in the response 
           
\end_layout

\begin_layout Plain Layout

        if response['error']:  
\end_layout

\begin_layout Plain Layout

            raise Exception(response['error'])
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    # Catch and print any exceptions during the data retrieval process 
        
\end_layout

\begin_layout Plain Layout

    except Exception as e:             
\end_layout

\begin_layout Plain Layout

        print(f"An error occurred: {e}")       # Print the specific error
 message             
\end_layout

\begin_layout Plain Layout

        print("Error while generating graph")  # Indicate a graph generation
 error
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    < rest of the code of the obtain_data() function >
\end_layout

\begin_layout Plain Layout


\backslash
end{python}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace 15bp
\end_inset


\end_layout

\begin_layout Standard
Para la obtención de datos a través de la consulta que hemos mostrado, se
 requieren los siguientes argumentos:
\end_layout

\begin_layout Itemize

\family typewriter
pair
\family default
.
 Denota el identificador del par de divisas para el cual se extraeran datos.
 Para ofrecer al usuario la posibilidad de elegir entre todos los pares
 de divisas para los que Kraken tiene información, hemos usado la librería
 requests para crear una función 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
pythoninline{def get_kraken_pairs()}
\end_layout

\end_inset

 que guarda en la tupla 
\family typewriter
kraken_pairs
\family default
 todos los pares de divisas disponibles a través del endpoint público 
\bar under
\color cyan

\begin_inset CommandInset href
LatexCommand href
name "AssetPairs"
target "https://api.kraken.com/0/public/AssetPairs"
literal "false"

\end_inset


\bar default
\color inherit
.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{python}
\end_layout

\begin_layout Plain Layout

# insertar el código de get_kraken_pairs()
\end_layout

\begin_layout Plain Layout


\backslash
end{python}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace 15bp
\end_inset


\end_layout

\begin_layout Standard
Para seleccionar un par de divisas de entre los disponibles, hemos utilizado
 streamlit para generar un menú dropdown en la aplicación (importamos esta
 librería como sigue: 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
pythoninline{import streamlit as st}
\end_layout

\end_inset

).
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{python}
\end_layout

\begin_layout Plain Layout

# Dropdown menu for selecting a currency pair         
\end_layout

\begin_layout Plain Layout

self.currency_pair = st.selectbox(
\end_layout

\begin_layout Plain Layout

    # Streamlit's selectbox requires a label, even when collapsed
\end_layout

\begin_layout Plain Layout

    label = 'placeholder',             
\end_layout

\begin_layout Plain Layout

    options = kraken_pairs,        # List of currency pairs from Kraken
            
\end_layout

\begin_layout Plain Layout

    index = None,                  # Index of the preselected option on
 first render            
\end_layout

\begin_layout Plain Layout

    placeholder = "xxxxxxx",       # Placeholder text in the dropdown  
          
\end_layout

\begin_layout Plain Layout

    label_visibility = "collapsed"         
\end_layout

\begin_layout Plain Layout

)
\end_layout

\begin_layout Plain Layout


\backslash
end{python}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{python}
\end_layout

\begin_layout Plain Layout

# captura de cómo se vería el dropdown menu
\end_layout

\begin_layout Plain Layout


\backslash
end{python}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize

\family typewriter
interval
\family default
.
 Denota el intervalo de tiempo (en minutos) que se utiliza para la agregación,
 es decir, cada vela del gráfico generado contará con datos de tantos minutos
 como el valor de 
\family typewriter
interval
\family default
.
 Para este atributo ofrecemos dos opciones al usuario: seleccionar entre
 los intervalos de tiempo más comunes (para los que 
\family typewriter
krakenex
\family default
 ofrece datos con una consulta directa) o escribir el valor del intervalo
 que desea seleccionar como un número entre entre 1 y 43200 (1 mes).
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{python}
\end_layout

\begin_layout Plain Layout

# poner código de cómo se ha tomado 
\end_layout

\begin_layout Plain Layout


\backslash
end{python}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Si el intervalo introducido es personalizado, utilizamos la función def
 find_largest_interval para realizar una consulta inicial y después agregar
 los valores con la función def aggregate_intervals()
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{python}
\end_layout

\begin_layout Plain Layout

# insertar el código de find_largest_interval y aggregate_intervals
\end_layout

\begin_layout Plain Layout


\backslash
end{python}
\end_layout

\end_inset

Since: El punto de partida para los datos, el punto final se determina por
 el intervalo.
 TODO captura del selector de fecha
\end_layout

\begin_layout Standard
Acto seguido limpiamos los datos con el siguiente codigo:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{python}
\end_layout

\begin_layout Plain Layout

# insertar el código
\end_layout

\begin_layout Plain Layout


\backslash
end{python}
\end_layout

\end_inset

Los datos los convertimos en un DataFrame de pandas para su posterior manipulaci
ón.
 Este DataFrame contiene las columnas, precios de apertura, cierre, alto
 y bajo, así como para el volumen de transacciones para cada intervalo de
 tiempo.
 
\end_layout

\begin_layout Subsection
Grabado de las cotizaciones
\end_layout

\begin_layout Enumerate
Graficar las velas con OHCL:
\end_layout

\begin_deeper
\begin_layout Standard
Creamos una figura candlestick de plotly y le pasamos los datos de OHCL.
 Adicionalmente añadimos un scatter de 'Simple moving average' y 'Exponential
 moving average' TODO explicacion adicional de los indicadores
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{python}
\end_layout

\begin_layout Plain Layout

   @staticmethod  # Static method to create a candlestick chart from OHLC
 data using Plotly     def candlestick(ohlc_df):         try:          
   # Use the last 60 data points from the OHLC DataFrame for the chart 
            df = ohlc_df[-60:]
\end_layout

\begin_layout Plain Layout

            # Define the candlestick chart components and moving averages
             data = [ go.Candlestick(x=df.index, open=df['Open'], high=df['High'],
                                    low=df['Low'], close=df['Close'], name='Cand
lestick Data'),
\end_layout

\begin_layout Plain Layout

                     go.Scatter(x=df.index, y=df['SMA'], name='Simple Moving
 Average'),                      go.Scatter(x=df.index, y=df['EMA'], name='Exponen
tial Moving Average') ]
\end_layout

\begin_layout Plain Layout

            # Define the layout for the plotly figure, setting titles and
 axis labels.
             layout = go.Layout(title='Candlestick Graph with Moving Average',
                                yaxis=dict(title='Price'))  # Label for
 the y-axis
\end_layout

\begin_layout Plain Layout

            fig = go.Figure(data=data, layout=layout)  # create a Figure
 object with the OHLC data             return fig  # return the Figure object
 for plotting                  except Exception as e:             # Handle
 exceptions in chart creation and return an empty figure in case of an error
             print(f"An error occurred while creating the candlestick chart:
 {e}")             return go.Figure()  # Return an empty Plotly Figure object
 if an error occurs
\end_layout

\begin_layout Plain Layout


\backslash
end{python}
\end_layout

\end_inset

TODO captura de candlestick
\end_layout

\end_deeper
\begin_layout Enumerate
Graficar el estocástico y la media móvil
\end_layout

\begin_deeper
\begin_layout Standard
El estocástico es un indicador de momentum desarrollado en los años 50.Se
 utiliza para mostrar la ubicación del cierre actual en relación con el
 rango alto/bajo durante un número determinado de períodos.La fórmula para
 calcular el estocástico es la siguiente:
\begin_inset Formula %K=(Preciodecierreactual-Mínimomásbajo)/(Máximomásalto-Mínimomásbajo)*100

\end_inset

Donde:- Precio de cierre actual: es el último precio al que se negoció un
 activo.- Mínimo más bajo: es el precio más bajo negociado del activo durante
 un período determinado.- Máximo más alto: es el precio más alto negociado
 del activo durante un período determinado.El estocástico se representa con
 dos líneas, %K y %D.
 La línea %D es una media móvil de %K.Cuando la línea %K cruza por encima
 de la línea %D, se genera una señal de compra.
 Cuando la línea %K cruza por debajo de la línea %D, se genera una señal
 de venta.
 TODO comprimir este parrafo a una o dos frases o borrar directamente
\end_layout

\begin_layout Standard
Explicación de nuestra forma de calcularlo: Primero, calcula el oscilador
 estocástico (%K) y su media móvil (%D) utilizando los precios de cierre,
 alto y bajo de un DataFrame de pandas.
 Luego, genera señales de compra y venta basadas en las condiciones especificada
s en las líneas 117 y 118.
\end_layout

\begin_layout Standard
La fórmula (df['Close'] - df['L14']) / (df['H14'] - df['L14']) * 100 es
 la implementación de la fórmula del oscilador estocásticoque mide la relación
 entre el precio de cierre actual y el rango de precios en un número determinado
 de períodos.
\end_layout

\begin_layout Standard
La línea df['%D'] = df['%K'].rolling(window=3).mean() calcula la media móvil
 de 3 períodos de %K, que se conoce como %D.
 La media móvil se utiliza para suavizar las fluctuaciones de %K y generar
 una línea de señal para las señales de compra y venta.
\end_layout

\begin_layout Standard
Tambien generamos las señales de compra y venta que utilizaremos en la simulacio
n de beneficios.
\end_layout

\begin_layout Itemize
Las de compra se generan cuando la línea %K cruza por encima de la línea
 %D y el valor de %D es menor que 20
\end_layout

\begin_layout Itemize
Las de venta se generan cuando la línea %K cruza por debajo de la línea
 %D y el valor de %D es mayor que 80
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{python}
\end_layout

\begin_layout Plain Layout

   @staticmethod
\end_layout

\begin_layout Plain Layout

  # Calculate and graph the stochastic oscillator and its mobile mean
\end_layout

\begin_layout Plain Layout

     def stochastic(df):
\end_layout

\begin_layout Plain Layout

        try:
\end_layout

\begin_layout Plain Layout

            window = 14 if df.shape[0]>=60 else 3
\end_layout

\begin_layout Plain Layout

            df['L14'] = df['Low'].rolling(window=window).min()
\end_layout

\begin_layout Plain Layout

           df['H14'] = df['High'].rolling(window=window).max()
\end_layout

\begin_layout Plain Layout

            df['%K'] = (df['Close'] - df['L14']) / (df['H14'] - df['L14'])
 * 100
\end_layout

\begin_layout Plain Layout

            df['%D'] = df['%K'].rolling(window=3).mean()
\end_layout

\begin_layout Plain Layout

            df['Buy_Signal'] = ((df['%K'] > df['%D']) & (df['%K'].shift(1)
 < df['%D'].shift(1))) & (df['%D'] < 20)             df['Sell_Signal'] =
 ((df['%K'] < df['%D']) & (df['%K'].shift(1) > df['%D'].shift(1))) & (df['%D']
 > 80)             
\end_layout

\begin_layout Plain Layout

			df = df[-60:]
\end_layout

\begin_layout Plain Layout

           data = [# The first plot is a line chart for the '%K' line of
 the stochastic oscillator                     go.Scatter(x=df.index, y=df['%K'],
 name='Stochastic Oscillator'),
\end_layout

\begin_layout Plain Layout

           # The second plot is a line chart for the '%D' line of the stochastic
 oscillator                     go.Scatter(x=df.index, y=df['%D'], name='Smoothed
 Stochastic Oscillator')]
\end_layout

\begin_layout Plain Layout

            # Define the layout for the plotly figure, setting titles and
 axis labels.
\end_layout

\begin_layout Plain Layout

            layout = go.Layout(title='Stochastic Oscillator with its Smoothed
 Version',                                yaxis=dict(title='Value (%)',
 range=[0,100]))  # Label for the y-axis
\end_layout

\begin_layout Plain Layout

            fig = go.Figure(data=data, layout=layout)  # create a Figure
 object with the candlestick data             return fig  # return the Figure
 object for plotting
\end_layout

\begin_layout Plain Layout

        except Exception as e:
\end_layout

\begin_layout Plain Layout

            print(f"An error occurred while creating the candlestick chart:
 {e}")
\end_layout

\begin_layout Plain Layout

            return go.Figure()
\end_layout

\begin_layout Plain Layout


\backslash
end{python}
\end_layout

\end_inset

TODO captura o capturas del K y D
\end_layout

\begin_layout Enumerate
Graficar los dos juntos
\end_layout

\begin_deeper
\begin_layout Standard
Finalmente damos al usuario la opción de graficar las anteriores opciones
 juntas.
 TODO captura graficas juntas
\end_layout

\begin_layout Standard
Adicionalmente aqui damos la opcion de simular ganancias que sera explicada
 en su seccion mas adelante TODO Es esta linea necesaria?
\end_layout

\end_deeper
\end_deeper
\begin_layout Enumerate
Calculadora de ganancias
\end_layout

\begin_deeper
\begin_layout Standard
Damos tambien la opción de hacer una pequeña simulación utilizando los datos
 que vemos en las graficas.
 Para ello cogemos las señales de compra y simulamos una cartera en la que
 compramos 100 unidades de la moneda por señal y vendemos 100 unidades por
 cada señal de venta.
 La grafica representa las ganancias o perdidas que se tendrian en el periodo.
\end_layout

\begin_layout Standard
No se muestra ninguna grafica si no se han generado señales de compra en
 el periodo.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{python}
\end_layout

\begin_layout Plain Layout

   def calculate_profit(self, df):
\end_layout

\begin_layout Plain Layout

        try:
\end_layout

\begin_layout Plain Layout

            coins = 0
\end_layout

\begin_layout Plain Layout

            total_spent = 0
\end_layout

\begin_layout Plain Layout

            df['Buy_Price'] = np.where(df['Buy_Signal'], df['Close'], np.nan)
             
\end_layout

\begin_layout Plain Layout

            df['Sell_Price'] = np.where(df['Sell_Signal'], df['Close'], np.nan)
\end_layout

\begin_layout Plain Layout

            for i in range(len(df)):
\end_layout

\begin_layout Plain Layout

                if df['Buy_Signal'].iloc[i]:
\end_layout

\begin_layout Plain Layout

                    coins += 100
\end_layout

\begin_layout Plain Layout

                    total_spent += df['Buy_Price'].iloc[i]*100
\end_layout

\begin_layout Plain Layout

                if df['Sell_Signal'].iloc[i] and coins >= 100:
\end_layout

\begin_layout Plain Layout

                    coins -= 100
\end_layout

\begin_layout Plain Layout

                    total_spent -= df['Sell_Price'].iloc[i]*100
\end_layout

\begin_layout Plain Layout

            df['Profit'] = df['Close'] * coins - total_spent
\end_layout

\begin_layout Plain Layout

            return df
\end_layout

\begin_layout Plain Layout

        except Exception as e:
\end_layout

\begin_layout Plain Layout

            print(f"An error occurred while creating the profit data: {e}")
\end_layout

\begin_layout Plain Layout

            return pd.DataFrame()
\end_layout

\begin_layout Plain Layout


\backslash
end{python}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{python}
\end_layout

\begin_layout Plain Layout

    def profit_graph(self, df):
\end_layout

\begin_layout Plain Layout

        try:
\end_layout

\begin_layout Plain Layout

            df = df[-60:]
\end_layout

\begin_layout Plain Layout

            if not df['Buy_Signal'].any():
\end_layout

\begin_layout Plain Layout

 		   # Check if there are any buy signals
\end_layout

\begin_layout Plain Layout

              return None  # Return None if no buy signals
\end_layout

\begin_layout Plain Layout

            first_buy_signal = df[df['Buy_Signal']].index[0]  # Get the index
 of the first buy signal           
\end_layout

\begin_layout Plain Layout

			df = df.loc[first_buy_signal:]  # Slice the DataFrame from the first buy
 signal onwards
\end_layout

\begin_layout Plain Layout

            data = [go.Scatter(x=df.index, y=df['Profit'].cumsum(), name='Profit'),
                     				go.Scatter(x=df[df['Buy_Signal']].index, y=df[df['Buy_Sig
nal']]['Profit'].cumsum(),mode='markers', marker=dict(color='green', size=10),
 name='Buy Signal'),                     				go.Scatter(x=df[df['Sell_Signal']].in
dex, y=df[df['Sell_Signal']]['Profit'].cumsum(), 			mode='markers', marker=dict(c
olor='red', size=10), name='Sell Signal')]             layout = 			go.Layout(titl
e='Profit',
\end_layout

\begin_layout Plain Layout

			xaxis=dict(title='Time'),   # label for the x-axis                  
        			yaxis=dict(title='Value'))  # Label for the y-axis
\end_layout

\begin_layout Plain Layout

           fig = go.Figure(data=data, layout=layout)  # create a Figure object
 with the profit data             			return fig  # return the Figure object
 for plotting
\end_layout

\begin_layout Plain Layout

        except Exception as e:
\end_layout

\begin_layout Plain Layout

            print(f"An error occurred while creating the profit chart: {e}")
\end_layout

\begin_layout Plain Layout

            return go.Figure()
\end_layout

\begin_layout Plain Layout


\backslash
end{python}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
TODO Captura de la grafica de beneficios
\end_layout

\end_deeper
\end_deeper
\begin_layout Section
Indicadores técnicos
\end_layout

\begin_layout Enumerate
Media movil exponencial
\end_layout

\begin_deeper
\begin_layout Standard
Es otro tipo de media movil que da mas peso a los datos mas recientes, lo
 que hace que sea mas sensibles a cambios a corto plazo.
 TODO confirmame que esto es correcto?
\end_layout

\end_deeper
\begin_layout Enumerate
Media movil media
\end_layout

\begin_deeper
\begin_layout Standard
TODO tenemos esto siquiera?, no es el smoothed stochastic oscilator?
\end_layout

\end_deeper
\begin_layout Subsection
Cálculo y representación gráfica del oscilador estocástico
\end_layout

\begin_layout Standard
El estocástico es un indicador de momentum desarrollado en los años 50.Se
 utiliza para mostrar la ubicación del cierre actual en relación con el
 rango alto/bajo durante un número determinado de períodos.La fórmula para
 calcular el estocástico es la siguiente:
\begin_inset Formula %K=(Preciodecierreactual-Mínimomásbajo)/(Máximomásalto-Mínimomásbajo)*100

\end_inset

Donde:- Precio de cierre actual: es el último precio al que se negoció un
 activo.- Mínimo más bajo: es el precio más bajo negociado del activo durante
 un período determinado.- Máximo más alto: es el precio más alto negociado
 del activo durante un período determinado.El estocástico se representa con
 dos líneas, %K y %D.
 La línea %D es una media móvil de %K.Cuando la línea %K cruza por encima
 de la línea %D, se genera una señal de compra.
 Cuando la línea %K cruza por debajo de la línea %D, se genera una señal
 de venta.
 TODO comprimir este parrafo a una o dos frases o borrar directamente
\end_layout

\begin_layout Standard
Explicación de nuestra forma de calcularlo: Primero, calcula el oscilador
 estocástico (%K) y su media móvil (%D) utilizando los precios de cierre,
 alto y bajo de un DataFrame de pandas.
 Luego, genera señales de compra y venta basadas en las condiciones especificada
s en las líneas 117 y 118.
\end_layout

\begin_layout Standard
La fórmula
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{python}
\end_layout

\begin_layout Plain Layout

(df['Close'] - df['L14']) / (df['H14'] - df['L14']) * 100 
\end_layout

\begin_layout Plain Layout


\backslash
end{python}
\end_layout

\end_inset

es la implementación de la fórmula del oscilador estocásticoque mide la
 relación entre el precio de cierre actual y el rango de precios en un número
 determinado de períodos.
\end_layout

\begin_layout Standard
La línea 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{python}
\end_layout

\begin_layout Plain Layout

df['%D'] = df['%K'].rolling(window=3).mean() 
\end_layout

\begin_layout Plain Layout


\backslash
end{python}
\end_layout

\end_inset

calcula la media móvil de 3 períodos de %K, que se conoce como %D.
 La media móvil se utiliza para suavizar las fluctuaciones de %K y generar
 una línea de señal para las señales de compra y venta.
\end_layout

\begin_layout Standard
Tambien generamos las señales de compra y venta que utilizaremos en la simulacio
n de beneficios.
\end_layout

\begin_layout Itemize
Las de compra se generan cuando la línea %K cruza por encima de la línea
 %D y el valor de %D es menor que 20
\end_layout

\begin_layout Itemize
Las de venta se generan cuando la línea %K cruza por debajo de la línea
 %D y el valor de %D es mayor que 80
\end_layout

\begin_layout Subsection
Cálculo del oscilador estocástico sobre una media móvil
\end_layout

\begin_layout Subsection
Gráfico del indicador junto con la cotización del par calculado
\end_layout

\begin_layout Standard
Graficar los dos juntos
\end_layout

\begin_layout Standard
Finalmente damos al usuario la opción de graficar las anteriores opciones
 juntas.
 TODO captura gráficas juntas
\end_layout

\begin_layout Standard
Adicionalmente aquí damos la opción de simular ganancias que será explciada
 en su sección más adelante TODO es esta línea necesaria?
\end_layout

\begin_layout Standard
(a) Media móvil exponencial
\end_layout

\begin_layout Standard
Es otro tipo de media movil que da mas peso a los datos mas recientes, lo
 que hace que sea mas sensibles a cambios a corto plazo.
 TODO confirmame que esto es correcto?
\end_layout

\begin_layout Standard
(b) Media móvil simple
\end_layout

\begin_layout Standard
TODO tenemos esto siquiera?, no es el smoothed stochastic oscillator?
\end_layout

\begin_layout Section
Estructuración
\end_layout

\begin_layout Standard

\series bold
\color violet
(añadir descripción)
\end_layout

\begin_layout Subsection
Funciones y utilizacion de clases
\end_layout

\begin_layout Standard
El proyecto se estructura en varios módulos y clases para facilitar la organizac
ión y la reutilización del código.
\end_layout

\begin_layout Standard
El módulo principal del proyecto es main.py, que importa y utiliza las funciones
 y clases definidas en otros módulos.
\end_layout

\begin_layout Standard
Los módulos adicionales incluyen graphs.py y front.py.
\end_layout

\begin_layout Standard
- graphs.py contiene la clase Graph que se encarga de crear gráficos de velas
 y osciladores estocásticos para el análisis de trading.
\end_layout

\begin_layout Standard
- front.py contiene la clase Front que se encarga de manejar la interfaz
 de usuario de la aplicación.
\end_layout

\begin_layout Standard
Además, el proyecto incluye un archivo README.md que proporciona una descripción
 general del proyecto y las instrucciones para su uso.
 También se incluye una carpeta docs que contiene varios archivos de texto
 que proporcionan más detalles sobre el proyecto y sus requisitos.
\end_layout

\begin_layout Subsection
Manejo de errores y excepciones
\end_layout

\begin_layout Standard
El manejo de excepciones en este proyecto se realiza principalmente a través
 de la estructura de control de flujo try/except.
 Esta estructura permite capturar y manejar errores que pueden ocurrir durante
 la ejecución del programa.
\end_layout

\begin_layout Standard
Por ejemplo en el metodo que genera la grafica de beneficios, en caso de
 encontrar un error imprime un mensaje por consola y retorna una figura
 vacia.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{python}
\end_layout

\begin_layout Plain Layout

   def profit_graph(self, df):
\end_layout

\begin_layout Plain Layout

     try:
\end_layout

\begin_layout Plain Layout

         [...]
\end_layout

\begin_layout Plain Layout

         fig = go.Figure(data=data, layout=layout)  # create a Figure object
 with the profit data
\end_layout

\begin_layout Plain Layout

         return fig  # return the Figure object for plotting         
\end_layout

\begin_layout Plain Layout

     except Exception as e:
\end_layout

\begin_layout Plain Layout

        print(f"An error occurred while creating the profit chart: {e}")
\end_layout

\begin_layout Plain Layout

        return go.Figure()
\end_layout

\begin_layout Plain Layout


\backslash
end{python}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
En esta ocasion por ejemplo imprimimos un mensaje de error directamente
 en la aplicación.
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{python}
\end_layout

\begin_layout Plain Layout

   # Method to execute the core operations of the Streamlit application
     
\end_layout

\begin_layout Plain Layout

   def run(self):
\end_layout

\begin_layout Plain Layout

     try:
\end_layout

\begin_layout Plain Layout

       [...]
\end_layout

\begin_layout Plain Layout

     except Exception as e:
\end_layout

\begin_layout Plain Layout

       # Handle and display any exceptions that occur during execution
\end_layout

\begin_layout Plain Layout

       st.error(f"An error occurred: {e}")  # Show the error message to the
 user in the app
\end_layout

\begin_layout Plain Layout


\backslash
end{python}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Testeo y cobertura (unit-testing, integration-testing)
\end_layout

\begin_layout Standard
Hemos gestionado los unit-test e intrgration tests con la libreria unittest.
 Este módulo permite definir clases de prueba con métodos que representan
 pruebas individuales.
 Aquí vemos un ejemplo de los tests que hemos añadido al proyecto.
 TODO poner algo mas aqui?
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{python}
\end_layout

\begin_layout Plain Layout

# Test method to test the get_kraken_pairs function
\end_layout

\begin_layout Plain Layout

    def test_get_kraken_pairs(self):
\end_layout

\begin_layout Plain Layout

        result = get_kraken_pairs()  # Calling the get_kraken_pairs function
 and storing its result
\end_layout

\begin_layout Plain Layout

        # Checking if the result is a tuple and has a length greater than
 0
\end_layout

\begin_layout Plain Layout

        self.assertIsInstance(result, tuple)
\end_layout

\begin_layout Plain Layout

        self.assertTrue(len(result) > 0)
\end_layout

\begin_layout Plain Layout


\backslash
end{python}
\end_layout

\end_inset

TODO Pideme un a captura de los tests pasando
\end_layout

\begin_layout Subsection
Facilitar los mecanismos para la reproducción del entorno virtual
\end_layout

\begin_layout Enumerate
Para añadir Poetry al proyecto, se ha utilizado el archivo pyproject.toml
 que se encuentra en la raíz del proyecto.
 Este archivo es utilizado por Poetry para manejar las dependencias del
 proyecto.
 En este archivo se especifican las dependencias del proyecto, la versión
 de Python requerida y otros metadatos del proyecto.
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{python}
\end_layout

\begin_layout Plain Layout

[tool.poetry]
\end_layout

\begin_layout Plain Layout

name = "krakenpythonmarcosrodrigo"
\end_layout

\begin_layout Plain Layout

version = "0.1.0"
\end_layout

\begin_layout Plain Layout

description = "A streamlit tool for rendering kraken data"
\end_layout

\begin_layout Plain Layout

authors = ["Your Name <you@example.com>"]
\end_layout

\begin_layout Plain Layout

readme = "README.md"
\end_layout

\begin_layout Plain Layout

[tool.poetry.dependencies]
\end_layout

\begin_layout Plain Layout

python = "^3.11"
\end_layout

\begin_layout Plain Layout

plotly = "4.14.3"
\end_layout

\begin_layout Plain Layout

streamlit = "0.79.0"
\end_layout

\begin_layout Plain Layout

coverage = "5.5"
\end_layout

\begin_layout Plain Layout

pandas = "2.1.4"
\end_layout

\begin_layout Plain Layout

numpy = "1.26.2"
\end_layout

\begin_layout Plain Layout

krakenex = "2.1.0"
\end_layout

\begin_layout Plain Layout

streamlit-option-menu = "0.3.6"
\end_layout

\begin_layout Plain Layout

[build-system]
\end_layout

\begin_layout Plain Layout

requires = ["poetry-core"]
\end_layout

\begin_layout Plain Layout

build-backend = "poetry.core.masonry.api"
\end_layout

\begin_layout Plain Layout


\backslash
end{python}
\end_layout

\end_inset

Para reproducir el entorno virtual utilizando Poetry, se deben seguir los
 siguientes pasos:
\end_layout

\begin_deeper
\begin_layout Standard
1.
 Instalar Poetry.
 Puedes hacerlo siguiendo las instrucciones en la documentación oficial
 de Poetry.
\end_layout

\begin_layout Standard
2.
 Clonar el repositorio del proyecto.
\end_layout

\begin_layout Standard
3.
 Navegar hasta el directorio del proyecto.
\end_layout

\begin_layout Standard
4.
 Ejecutar el comando 
\begin_inset ERT
status open

\begin_layout Plain Layout

Poetry install
\end_layout

\end_inset

 Este comando instalará todas las dependencias especificadas en el archivo
 pyproject.toml.
\end_layout

\begin_layout Standard
5.
 Para activar el entorno virtual creado por Poetry, ejecuta el comando poetry
 shell.
 
\end_layout

\end_deeper
\begin_layout Subsection
Distribución del proyecto a través de PyPi
\end_layout

\begin_layout Standard
Primero se han instalado las dependencias de desarrollo Hatch y Twine
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
pythoninline{$pip install hatch}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
pythoninline{$pip install pip twine}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
2.
 Crear una cuenta en PyPI, adicionalmente se necesitara activar la autenticancio
n de doble factor y se debe utilizar la token de la api en twine
\end_layout

\begin_layout Standard
3.
 Para crear el distribuible: 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
pythoninline{$hatch build}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
4.
 Para publicar el paquete:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
pythoninline{$twine upload dist/*}
\end_layout

\end_inset

(con tu cuenta de pypi)
\end_layout

\begin_layout Subsection
Distribución del proyecto a través de Dockerhub
\end_layout

\begin_layout Standard
Para crear la imagen que se ha subido a dockerhub se han segido los siguientes
 pasos:
\end_layout

\begin_layout Enumerate
Creado un dockerfile que describa el contenedor:
\end_layout

\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{python}
\end_layout

\begin_layout Plain Layout

# Use an official Python runtime as a parent image 
\end_layout

\begin_layout Plain Layout

FROM python:3.11-slim-buster
\end_layout

\begin_layout Plain Layout

# Set the working directory in the container to /app 
\end_layout

\begin_layout Plain Layout

WORKDIR /app
\end_layout

\begin_layout Plain Layout

# Add the current directory contents into the container at /app 
\end_layout

\begin_layout Plain Layout

ADD .
 /app
\end_layout

\begin_layout Plain Layout

# Install Poetry 
\end_layout

\begin_layout Plain Layout

RUN pip install poetry
\end_layout

\begin_layout Plain Layout

# Use Poetry to install dependencies 
\end_layout

\begin_layout Plain Layout

RUN poetry install
\end_layout

\begin_layout Plain Layout

# Make port 80 available to the world outside this container 
\end_layout

\begin_layout Plain Layout

EXPOSE 8501
\end_layout

\begin_layout Plain Layout

# Run main.py when the container launches 
\end_layout

\begin_layout Plain Layout

CMD ["poetry", "run", "streamlit", "run", "main.py"]
\end_layout

\begin_layout Plain Layout


\backslash
end{python}
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
Construimos la imagen de docker con:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
pythoninline{$docker build -t dixrow/krakenpythonmarcosrodrigo .}
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Creamos una cuenta de docker y la enlazamos con:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
pythoninline{$docker login}
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Subimos la imagen que hemos creado con:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
pythoninline{$docker push dixrow/krakenpythonmarcosrodrigo:latest}
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Para bajarse la imagen de dockerhub:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
pythoninline{$docker pull dixrow/krakenpythonmarcosrodrigo}
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Para ejecutar la imagen:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
pythoninline{$docker run -p 8501:8501 dixrow/krakenpythonmarcosrodrigo}
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Por último puedes acceder a traves del navegador con el enlaze: 
\begin_inset ERT
status open

\begin_layout Plain Layout

localhost:8501
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Acceso a traves de Streamlit
\end_layout

\begin_layout Standard
Alternativamente se puede acceder a la aplicacion a traves del siguiente
 enlaze:
\end_layout

\begin_layout Standard

\end_layout

\end_body
\end_document
