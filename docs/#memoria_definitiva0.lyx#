#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass article
\begin_preamble
\date{}

% Default fixed font does not support bold face
\DeclareFixedFont{\ttb}{T1}{txtt}{bx}{n}{10} % for bold
\DeclareFixedFont{\ttm}{T1}{txtt}{m}{n}{10}  % for normal

% Custom colors
\usepackage{color}
\definecolor{deepblue}{rgb}{0,0,0.5}
\definecolor{deepred}{rgb}{0.6,0,0}
\definecolor{deepgreen}{rgb}{0,0.5,0}

\usepackage{listings}

% Python style for highlighting
\newcommand\pythonstyle{\lstset{
language=Python,
basicstyle=\ttm,
morekeywords={self},              % Add keywords here
keywordstyle=\ttb\color{deepblue},
emph={MyClass,__init__},          % Custom highlighting
emphstyle=\ttb\color{deepred},    % Custom highlighting style
stringstyle=\color{deepgreen},
frame=tb,                         % Any extra options here
showstringspaces=false
}}


% Python environment
\lstnewenvironment{python}[1][]
{
\pythonstyle
\lstset{#1}
}
{}

% Python for external files
\newcommand\pythonexternal[2][]{{
\pythonstyle
\lstinputlisting[#1]{#2}}}

% Python for inline
\newcommand\pythoninline[1]{{\pythonstyle\lstinline!#1!}}
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 2.5cm
\topmargin 3cm
\rightmargin 2.5cm
\bottommargin 3cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation 0bp
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard

\series bold
\size largest
Python para el Análisis de Datos.
 Proyecto Final (MEBDS)
\end_layout

\begin_layout Standard
\align center
Realizado por
\emph on
: Rodrigo de la Nuez Moraleda 
\emph default
y
\emph on
 Marcos Castro Cacho
\end_layout

\begin_layout Standard
\begin_inset VSpace 15bp
\end_inset


\end_layout

\begin_layout Standard

\series bold
\color teal
Descripción de 
\bar under
cómo
\bar default
 se ha afrontado el proyecto y 
\bar under
por qué
\bar default
.
\end_layout

\begin_layout Standard
Este proyecto se ha llevado a cabo con el objetivo de aplicar y profundizar
 en los conocimientos adquiridos en la asignatura 
\shape italic
Python para el Análisis de Datos
\shape default
.
 Combinando el aprendizaje académico con nuestra propia investigación de
 librerías y herramientas externas, hemos creado una aplicación que permite
 analizar datos reales y actualizados de los precios de distintos pares
 de divisas.
\begin_inset Newline newline
\end_inset

 
\end_layout

\begin_layout Standard
Para ello se ha creado una interfaz interactiva que permite crear un gráfico
 de velas, junto con varios indicadores bursátiles, a partir de la información
 OHLC de un par de divisas específico, el intervalo de tiempo usado para
 la agregación y, opcionalmente, un marco temporal que acote los resultados.
 
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
El proceso que se ha seguido para afrontar el proyecto y llevar a cabo el
 desarrollo del programa creado se puede dividir en varias fases.
 En primer lugar, estudiamos los datos devueltos por la API de Kraken para
 el par ETH/USDT con el objetivo de comprender la estructura de los mismos,
 así como la mejor manera de manipularlos para lograr nuestros objetivos.
 Tras ello, utilizamos 
\shape italic
webscraping
\shape default
 para obtener todos los pares de divisas disponibles en la API y tener capacidad
 de elección entre estas opciones.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Para la representación gráfica de la cotización de las divisas y los indicadores
 calculados, se hicieron pruebas con distintas librerías (
\family typewriter
matplotlib
\family default
, 
\family typewriter
mplfinance
\family default
); pero finalmente optamos por utilizar 
\family typewriter
plotly
\family default
 para ello.
 Por último, estudiamos como utilizar 
\family typewriter
streamlit
\family default
 para ofrecer al usuario una experiencia interactiva.
 Tras este punto, centramos nuestros esfuerzos en refinar nuestro código
 (añadir nuevas funcionalidades, mejorar el proceso y la estructura, comentar
 su funcionamiento, etc.), agregar pruebas que nos permitan evaluar la corrección
 de nuestro programa, estudiar la reproducción de nuestro entorno a través
 de distintas herramientas y documentar de todo el proceso en esta memoria.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard

\series bold
\color teal
Descripción de la 
\bar under
estructura del código
\bar default
 y 
\bar under
estructura de ficheros
\bar default
.
\end_layout

\begin_layout Standard
Nuestro programa necesita de tres ficheros distintos para su correcta ejecución:
\end_layout

\begin_layout Itemize

\family typewriter
graphs.py
\family default
, que contiene la 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
pythoninline{class Graph}
\end_layout

\end_inset

 con métodos para la obtención de los datos y la representación gráfica
 de los mismos (junto con los indicadores asociados), según el par de divisas,
 el intervalo de agregación y el marco temporal seleccionados.
\end_layout

\begin_layout Itemize

\family typewriter
front.py
\family default
, que contiene la 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
pythoninline{class Front}
\end_layout

\end_inset

.
 Esta crea la interaz de usuario con la que se puede interactuar, de forma
 que la información mostrada coincida con la seleccionada, haciendo uso
 de los 
\shape italic
widgets
\shape default
 y botones que 
\family typewriter
streamlit
\family default
 proporciona para la rápida y fácil creación de aplicaciones web.
\end_layout

\begin_layout Itemize

\family typewriter
main.py
\family default
, que contiene el código necesario para la ejecución de la aplicación.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Estos ficheros deben encontrarse en el mismo directorio para que el programa
 pueda acceder a las distintas funcionalidades que han sido creadas sin
 la aparición de excepciones.
 Contamos, además, con un fichero 
\family typewriter
tests.py
\family default
 para la ejecución de las pruebas de software creadas; un fichero 
\family typewriter
requirements.txt
\family default
 para poder instalar fácilmente todas las librerías necesarias, con las
 versiones adecuadas.
 para la ejecución del código; un fichero 
\family typewriter
setup.py
\family default
 
\series bold
\color violet
(añadir descripción)
\series default
\color inherit
 y un fichero 
\family typewriter
dockerfile
\family default
 
\series bold
\color violet
(añadir descripción)
\series default
\color inherit
.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard

\series bold
\color teal
Descripción de la 
\bar under
forma de ejecución del código
\bar default
.
\end_layout

\begin_layout Standard
El comando 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
pythoninline{streamlit run main.py}
\end_layout

\end_inset

 permite la ejecución del programa desde su directorio.
\end_layout

\begin_layout Section
Lectura y representación del movimiento del par de monedas
\end_layout

\begin_layout Standard

\series bold
\color violet
(añadir descripción)
\end_layout

\begin_layout Subsection
Descarga de los datos
\end_layout

\begin_layout Standard
Para la descarga de los datos contábamos con las siguientes posibilidades:
 utilizar la librería 
\family typewriter
krakenex
\family default
, hacer una descarga directa a través de 
\family typewriter
pandas
\family default
 o descargar directamente el 
\family typewriter
.csv
\family default
 y utilizar el archivo de forma local.
 
\end_layout

\begin_layout Standard
Debido a que de estas tres opciones la única que permite recoger información
 de distintos pares de divisas para crear una herramienta interactiva es
 la primera de ellas, nuestro programa lleva a cabo esta fase del proceso
 a través de una consulta a la API de Kraken usando la librería 
\family typewriter
krakenex
\family default
.
\begin_inset Newline newline
\end_inset

 
\end_layout

\begin_layout Standard
En la 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
pythoninline{class Graph}
\end_layout

\end_inset

 del fichero 
\family typewriter
graphs.py
\family default
, inicializamos el cliente de Kraken para hacer una llamada al endpoint
 publico OHLC con la función 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
pythoninline{def obtain_data(self)}
\end_layout

\end_inset

 y almacenamos en un dataframe de 
\family typewriter
pandas
\family default
 toda la información recogida en la consulta para la selección escogida
 por el usuario.
 
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Esta clase se inicializa como se muestra en el siguiente fragmento del código:
\begin_inset VSpace 5bp
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{python}
\end_layout

\begin_layout Plain Layout

class Graph:
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    # Constructor for initializing a Graph instance
\end_layout

\begin_layout Plain Layout

    def __init__(self, pair='XETHZUSD', interval=1440, divisor=1, 
\end_layout

\begin_layout Plain Layout

                       since=None, until=None):
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        self.pair = pair          # The currency pair to be analyzed    
     
\end_layout

\begin_layout Plain Layout

        self.interval = interval  # Time interval for each data point in
 minutes         
\end_layout

\begin_layout Plain Layout

        self.divisor = divisor    # Divisor for interval adjustment     
    
\end_layout

\begin_layout Plain Layout

        self.since = since        # Start of the time window        
\end_layout

\begin_layout Plain Layout

        self.until = until        # Time limit for the time window
\end_layout

\begin_layout Plain Layout


\backslash
end{python}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace 25bp
\end_inset


\end_layout

\begin_layout Standard
Para la obtención de datos a través de la consulta a la API, se requieren
 los siguientes argumentos:
\end_layout

\begin_layout Itemize

\family typewriter
pair
\family default
.
 Denota el identificador del par de divisas para el cual se extraerán datos.
 Para ofrecer al usuario la posibilidad de elegir entre todos los pares
 de divisas para los que Kraken tiene información, hemos usado la librería
 
\family typewriter
requests
\family default
 para crear en 
\family typewriter
front.py
\family default
 una función 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
pythoninline{def get_kraken_pairs()}
\end_layout

\end_inset

 que guarda en la tupla 
\family typewriter
kraken_pairs
\family default
 todos los pares de divisas disponibles a través del endpoint público 
\bar under
\color cyan

\begin_inset CommandInset href
LatexCommand href
name "AssetPairs"
target "https://api.kraken.com/0/public/AssetPairs"
literal "false"

\end_inset


\bar default
\color inherit
.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{python}
\end_layout

\begin_layout Plain Layout

# Import the requests library for HTTP request handling
\end_layout

\begin_layout Plain Layout

import requests  
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Retrieves all available currency pairs from the Kraken API 
\end_layout

\begin_layout Plain Layout

def get_kraken_pairs():
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    # Endpoint URL for fetching Kraken currency pairs  
\end_layout

\begin_layout Plain Layout

    url = 'https://api.kraken.com/0/public/AssetPairs'
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    # Send a GET request to the Kraken API       
\end_layout

\begin_layout Plain Layout

    response = requests.get(url)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    # Convert the response to JSON format                            
\end_layout

\begin_layout Plain Layout

    response_json = response.json()
\end_layout

\begin_layout Plain Layout

    # Extract currency pair identifiers from the JSON data             
         
\end_layout

\begin_layout Plain Layout

    pairs = response_json['result'].keys()
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    # Return the currency pairs as a tuple                
\end_layout

\begin_layout Plain Layout

    return tuple(pairs)                                 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Get and store the list of currency pairs available on Kraken
\end_layout

\begin_layout Plain Layout

kraken_pairs = get_kraken_pairs()  
\end_layout

\begin_layout Plain Layout


\backslash
end{python}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace 15bp
\end_inset

Para seleccionar un par de divisas de entre los disponibles, hemos utilizado
 
\family typewriter
streamlit
\family default
 para generar un menú dropdown en la aplicación (importamos esta librería
 como sigue: 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
pythoninline{import streamlit as st}
\end_layout

\end_inset

).
\begin_inset VSpace 5bp
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{python}
\end_layout

\begin_layout Plain Layout

# Prompt user to select a currency pair from the pairs retrieved       
  
\end_layout

\begin_layout Plain Layout

st.write("1.
 Please select a currency pair from the available options:")
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Dropdown menu for selecting a currency pair         
\end_layout

\begin_layout Plain Layout

self.currency_pair = st.selectbox(           
\end_layout

\begin_layout Plain Layout

    label = 'placeholder',            # Streamlit's selectbox requires a
 label           
\end_layout

\begin_layout Plain Layout

    options = kraken_pairs,           # List of currency pairs from Kraken
            
\end_layout

\begin_layout Plain Layout

    index = None,                     # Index of the preselected option
\end_layout

\begin_layout Plain Layout

    placeholder = "xxxxxxx",          # Placeholder text in the dropdown
            
\end_layout

\begin_layout Plain Layout

    label_visibility = "collapsed"         
\end_layout

\begin_layout Plain Layout

)
\end_layout

\begin_layout Plain Layout


\backslash
end{python}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace 10bp
\end_inset


\end_layout

\begin_layout Standard
Así se vería el menú dropdown en la aplicación creada con 
\family typewriter
streamlit
\family default
:
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename dropdown_menu.JPG
	scale 75

\end_inset


\begin_inset VSpace 10bp
\end_inset


\end_layout

\begin_layout Itemize

\family typewriter
interval
\family default
.
 Denota el intervalo de tiempo (en minutos) que se utiliza para la agregación,
 es decir, cada vela del gráfico generado contará con datos de tantos minutos
 como el valor de 
\family typewriter
interval
\family default
.
 Para este atributo ofrecemos dos opciones al usuario: seleccionar entre
 los intervalos de tiempo más comunes (para los que 
\family typewriter
krakenex
\family default
 ofrece datos con una consulta directa y así se indica en la 
\bar under
\color cyan

\begin_inset CommandInset href
LatexCommand href
name "documentación"
target "https://docs.kraken.com/rest/#tag/Market-Data/operation/getOHLCData"
literal "false"

\end_inset


\bar default
\color inherit
) o escribir el valor del intervalo que desea seleccionar como un número
 entero entre 1 y 43200 (1 mes).
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{python}
\end_layout

\begin_layout Plain Layout

# A dictionary mapping time intervals to their durations in minutes 
\end_layout

\begin_layout Plain Layout

intervals = {"1m":1, "5m":5, "15m":15, "30m":30, "1h":60, "4h":240,
\end_layout

\begin_layout Plain Layout

             "1d":1440, "1w":10080, "2w":21600} 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Separate lists of interval labels and their corresponding durations
\end_layout

\begin_layout Plain Layout

keys, options = intervals.keys(), intervals.values()  
\end_layout

\begin_layout Plain Layout


\backslash
end{python}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Si el intervalo toma un valor a elección del usuario, utilizamos la función
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
pythoninline{def find_largest_interval(n)}
\end_layout

\end_inset

 en 
\family typewriter
front.py
\family default
 para realizar la consulta con el mayor divisor de entre los intervalos
 predeterminados del entero introducido.
 La función 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
pythoninline{def aggregate_intervals(self, df)}
\end_layout

\end_inset

 en 
\family typewriter
graphs.py
\family default
 permite la agregación de los distintos campos según el intervalo que el
 usuario ha seleccionado desde la aplicación.
\begin_inset VSpace 5bp
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{python}
\end_layout

\begin_layout Plain Layout

# Finds the largest duration in 'options' that is a divisor of n 
\end_layout

\begin_layout Plain Layout

def find_largest_divisor(n):  
\end_layout

\begin_layout Plain Layout

    # Filters durations that are divisors of n  
\end_layout

\begin_layout Plain Layout

    valid_divisors = [d for d in options if n % d == 0] 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    # Returns the largest divisor found  
\end_layout

\begin_layout Plain Layout

    return max(valid_divisors)                            
\end_layout

\begin_layout Plain Layout


\backslash
end{python}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace 15bp
\end_inset

Llevamos a cabo este proceso ya que la consulta a la API de Kraken devuelve
 una respuesta con un límite de tamaño de 720 intervalos por consulta.
 Debido a ello, al realizar ciertas agregaciones obtendremos unos pocos
 valores en nuestra gráfica.
 Este problema se podría solucionar realizando múltiples consultas a la
 API y juntando las respuestas a las distintas consultas antes de realizar
 la agregación.
 Sin embargo, esto no es posible pues, al hacer varias consultas de forma
 muy seguida, recogemos el siguiente mensaje de error:
\begin_inset VSpace 5bp
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{python}
\end_layout

\begin_layout Plain Layout

There was an error with the API call 
\end_layout

\begin_layout Plain Layout

An error occurred: ['EGeneral:Too many requests']
\end_layout

\begin_layout Plain Layout


\backslash
end{python}
\end_layout

\end_inset


\begin_inset VSpace 15bp
\end_inset


\end_layout

\begin_layout Standard
Para la selección del intervalo entre las distintas opciones, hemos creado
 un conjunto de botones y un objeto 
\family typewriter
number_input
\family default
 de 
\family typewriter
streamlit
\family default
 que únicamente acepta números enteros entre 1 y 43200 (ambos incluidos).
\begin_inset VSpace 5bp
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{python}
\end_layout

\begin_layout Plain Layout

class Front:
\end_layout

\begin_layout Plain Layout

    def __init__(self):
\end_layout

\begin_layout Plain Layout

        < código de la función >
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        # Retrieve or initialize the selected time interval for each candle
\end_layout

\begin_layout Plain Layout

        st.session_state.selected_option = st.session_state.get("selected_option")
\end_layout

\begin_layout Plain Layout

        st.session_state.is_custom_interval = st.session_state.get("is_custom_interv
al")
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        # Store the time interval for each candle from the session state
\end_layout

\begin_layout Plain Layout

        st.session_state.custom_interval = st.session_state.get("custom_interval")
\end_layout

\begin_layout Plain Layout

        self.time_interval = st.session_state.selected_option
\end_layout

\begin_layout Plain Layout

     
\end_layout

\begin_layout Plain Layout

        < código de la función > 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    def select_boxes(self):
\end_layout

\begin_layout Plain Layout

        < código de la función >
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        st.markdown("2.
 Choose a time interval for the candles from 
\end_layout

\begin_layout Plain Layout

                                     the most commonly used options..." + 
             
\end_layout

\begin_layout Plain Layout

            f"""             
\end_layout

\begin_layout Plain Layout

            <style>             
\end_layout

\begin_layout Plain Layout

            div.stButton > button {{                 
\end_layout

\begin_layout Plain Layout

                width: 100%;             
\end_layout

\begin_layout Plain Layout

            }}             
\end_layout

\begin_layout Plain Layout

            </style>""", unsafe_allow_html=True )                  
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        # Generate a row of buttons for selecting time intervals       
  
\end_layout

\begin_layout Plain Layout

        columns = st.columns(len(keys))         
\end_layout

\begin_layout Plain Layout

        for i, key in enumerate(keys):             
\end_layout

\begin_layout Plain Layout

            with columns[i]:                 
\end_layout

\begin_layout Plain Layout

                button_key = f"button-{key}"                 
\end_layout

\begin_layout Plain Layout

                if st.button(key, key=button_key):
\end_layout

\begin_layout Plain Layout

                    # Sets the selected time interval
\end_layout

\begin_layout Plain Layout

                    self.time_interval = int(intervals[key])
\end_layout

\begin_layout Plain Layout

                    # Updates the session state                        
           
\end_layout

\begin_layout Plain Layout

                    st.session_state.selected_option = self.time_interval 
 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        # Button for allowing custom time interval input         
\end_layout

\begin_layout Plain Layout

        if st.button("...or enter a custom time interval (in minutes)", key="Other")
:             
\end_layout

\begin_layout Plain Layout

            # Input field for custom time interval in minutes          
   
\end_layout

\begin_layout Plain Layout

            st.session_state.is_custom_interval = not st.session_state.is_custom_int
erval
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        if st.session_state.is_custom_interval:             
\end_layout

\begin_layout Plain Layout

            st.session_state.custom_interval = st.number_input('Custom interval',
 
\end_layout

\begin_layout Plain Layout

                min_value=1, max_value=43200, step=1, 
\end_layout

\begin_layout Plain Layout

                value=None, label_visibility='collapsed')              
        
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        if st.session_state.custom_interval is not None:              
\end_layout

\begin_layout Plain Layout

            self.time_interval = st.session_state.custom_interval 
\end_layout

\begin_layout Plain Layout

            # Update the time interval with the custom input           
\end_layout

\begin_layout Plain Layout

            st.session_state.selected_option = st.session_state.custom_interval
 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        < código de la función >
\end_layout

\begin_layout Plain Layout


\backslash
end{python}
\end_layout

\end_inset


\begin_inset VSpace 15bp
\end_inset

Así se verían el conjunto de botones y el 
\family typewriter
number_input
\family default
 en la aplicación creada con 
\family typewriter
streamlit
\family default
:
\begin_inset VSpace 5bp
\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename time_buttons.JPG
	scale 85

\end_inset


\begin_inset VSpace 15bp
\end_inset


\end_layout

\begin_layout Itemize

\family typewriter
since
\family default
.
 Denota el tiempo para el cual se toman los primeros datos en la consulta,es
 un número entero que se corresponde con un timestamp de Unix.
 Este valor es el el número de segundos transcurridos desde la medianoche
 UTC del 1 de enero de 1970.
 Por ejemplo, el timestamp Unix "1548111600" se correspondería con la fecha
 y hora "2019-01-21 23:00:00 UTC".
 Cabe destacar que si el tiempo introducido es anterior al primero de los
 720 intervalos devueltos por la API, esta funcionalidad no empezará en
 el tiempo indicado sino en el primero de esos 720 intervalos.
 
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace 5bp
\end_inset

Además, hemos buscado acotar la última fecha para la que se muestran datos
 y, dado que 
\family typewriter
krakenex
\family default
 no cuenta con dicha funcionalidad, hemos añadido un atributo 
\family typewriter
until
\family default
 a la 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
pythoninline{class Graph}
\end_layout

\end_inset

 con el que aplicamos un filtro tras la obtención de los datos.
 Para la selección de los valores de 
\family typewriter
since
\family default
 y 
\family typewriter
until
\family default
, hemos usado las funcionalidades de 
\family typewriter
streamlit
\family default
 para crear dos objetos 
\family typewriter
expander
\family default
 con un 
\family typewriter
date_input
\family default
 cada uno.
\begin_inset VSpace 20bp
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{python}
\end_layout

\begin_layout Plain Layout

class Front:
\end_layout

\begin_layout Plain Layout

    def __init__(self):
\end_layout

\begin_layout Plain Layout

        < código de la función >
\end_layout

\begin_layout Plain Layout

                                         
\end_layout

\begin_layout Plain Layout

        # Initialize since and until attributes
\end_layout

\begin_layout Plain Layout

        self.since, self.until = None, None
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    # Method to create user input interfaces, including dropdowns and buttons
\end_layout

\begin_layout Plain Layout

    def select_boxes(self):
\end_layout

\begin_layout Plain Layout

        < código de la función >
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        st.markdown("3.
 Optionally, choose a time interval within 
\end_layout

\begin_layout Plain Layout

                              the range of the original selection:")   
               
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        # Date picker for selecting the start date         
\end_layout

\begin_layout Plain Layout

        columns0, columns1 = st.columns([1, 1])         
\end_layout

\begin_layout Plain Layout

        with columns0:             
\end_layout

\begin_layout Plain Layout

            with st.expander("Start Date", expanded=True):              
   
\end_layout

\begin_layout Plain Layout

                self.since = st.date_input('start', value=None, 
\end_layout

\begin_layout Plain Layout

                                           label_visibility = "collapsed")
                 
\end_layout

\begin_layout Plain Layout

                if self.since is not None:                     
\end_layout

\begin_layout Plain Layout

                    # Convert date to datetime                     
\end_layout

\begin_layout Plain Layout

                    self.since = datetime.datetime.combine(self.since, 
\end_layout

\begin_layout Plain Layout

                                                datetime.datetime.min.time())
                     
\end_layout

\begin_layout Plain Layout

                    self.since = datetime.datetime.strptime(str(self.since),
 
\end_layout

\begin_layout Plain Layout

                                             "%Y-%m-%d %H:%M:%S").timestamp()
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        with columns1:             
\end_layout

\begin_layout Plain Layout

            with st.expander("End Date", expanded=True):                
 
\end_layout

\begin_layout Plain Layout

                self.until = st.date_input('end', value=None, 
\end_layout

\begin_layout Plain Layout

                                           label_visibility = "collapsed")
                 
\end_layout

\begin_layout Plain Layout

                if self.until is not None:                     
\end_layout

\begin_layout Plain Layout

                    # Convert date to datetime                     
\end_layout

\begin_layout Plain Layout

                    self.until = datetime.datetime.combine(self.until, 
\end_layout

\begin_layout Plain Layout

                                                datetime.datetime.min.time())
\end_layout

\begin_layout Plain Layout

                    self.until = datetime.datetime.strptime(str(self.until),
 
\end_layout

\begin_layout Plain Layout

                                             "%Y-%m-%d %H:%M:%S").timestamp()
\end_layout

\begin_layout Plain Layout


\backslash
end{python}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Standard
Así se verían los objetos 
\family typewriter
expander
\family default
 con el 
\family typewriter
date_input
\family default
 en la aplicación creada con 
\family typewriter
streamlit
\family default
:
\begin_inset VSpace 5bp
\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename since_until.JPG
	scale 85

\end_inset


\begin_inset VSpace 15bp
\end_inset


\end_layout

\begin_layout Standard
Con los inputs mencionados, en la función 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
pythoninline{def obtain_data(self)}
\end_layout

\end_inset

 se lleva a cabo la consulta con la que se recuperan los datos en formato
 JSON, con dos campos 
\family typewriter
response
\family default
 y 
\family typewriter
error
\family default
.
 En caso de haber algún problema con la llamada a la API, se recoge la excepción
 en el campo 
\family typewriter
error
\family default
 y, de no ser así, el campo 
\family typewriter
response
\family default
 a su vez guarda la información de los campos 
\family typewriter
Time
\family default
 (tiempo de apertura del intervalo), 
\family typewriter
Open
\family default
 (precio de apertura del intervalo), 
\family typewriter
High
\family default
 (precio más alto del intervalo), 
\family typewriter
Low
\family default
 (precio más bajo del intervalo), 
\family typewriter
Close
\family default
 (precio de cierre del intervalo), 
\family typewriter
VWAP
\family default
 (valor del indicador para el intervalo), 
\family typewriter
Volume
\family default
 (volumen acumulado del intervalo) y 
\family typewriter
Count
\family default
 (número de transacciones en el intervalo).
 
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Transformamos los datos a un dataframe de 
\family typewriter
pandas
\family default
 y prescindimos de los campos 
\family typewriter
VWAP
\family default
 y 
\family typewriter
Count
\family default
, pues no nos son de utilidad.
 Cambiamos los timestamps de Unix al tipo 
\family typewriter
datetime
\family default
 de 
\family typewriter
pandas
\family default
 y el resto de campos de 
\family typewriter
float
\family default
 a 
\family typewriter
string
\family default
.
 Además, calculamos dos indicadores que incluiremos en el gráfico de velas:
 el SMA o 
\shape italic
Simple Moving Average
\shape default
 (media móvil del precio de cierre) y el EMA o 
\shape italic
Exponential Moving Average
\shape default
 (similar al SMA pero dando más peso a los datos mas recientes, lo que hace
 que sea más sensible a cambios a corto plazo).
 En el cálculo de medias móviles, como es este caso, existe la convención
 de tomar 14 intervalos y, aunque esta elección puede variar según el análisis
 que se busque hacer sobre los datos, hemos decidido adoptar este estándar
 para nuestra aplicación.
 Además, hemos tenido en cuenta casos en los que la consulta no devuelve
 datos para muchos intervalos
\begin_inset VSpace 5bp
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{python}
\end_layout

\begin_layout Plain Layout

class Graph: 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    # Retrieves trading data from the Kraken API and stores it in a Pandas
 DataFrame     
\end_layout

\begin_layout Plain Layout

    def obtain_data(self):                  
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

        # Initializing a Kraken API client and querying data within a try-except
 block         
\end_layout

\begin_layout Plain Layout

        try:             
\end_layout

\begin_layout Plain Layout

            k = krakenex.API()  # Initialize the Kraken client          
                
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

            # Query for OHLC data for the specified currency pair and interval
             
\end_layout

\begin_layout Plain Layout

            response = k.query_public('OHLC', {'pair':self.pair, 
\end_layout

\begin_layout Plain Layout

                                      'interval':self.divisor, 
\end_layout

\begin_layout Plain Layout

                                      'since':self.since})
\end_layout

\begin_layout Plain Layout

   
\end_layout

\begin_layout Plain Layout

            # Check and raise an exception if errors exist in the response
        
\end_layout

\begin_layout Plain Layout

            if response['error']:                   
\end_layout

\begin_layout Plain Layout

                print(f"There was an error with the API call")         
        
\end_layout

\begin_layout Plain Layout

                raise Exception(response['error'])
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        # Catch and print any exceptions during the data retrieval process
         
\end_layout

\begin_layout Plain Layout

        except Exception as e:             
\end_layout

\begin_layout Plain Layout

            print(f"An error occurred: {e}")       # Print the specific
 error message             
\end_layout

\begin_layout Plain Layout

            print("Error while retrieving data")   # Indicate a data retrieval
 error
\end_layout

\begin_layout Plain Layout

        
\end_layout

\begin_layout Plain Layout

        # Process the retrieved data if no exceptions occur          
\end_layout

\begin_layout Plain Layout

        else:
\end_layout

\begin_layout Plain Layout

            # Extract OHLC data from API response            
\end_layout

\begin_layout Plain Layout

            ohlc_data = response['result'][self.pair]  
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

            # Convert OHLC data to a DataFrame and remove unnecessary columns
             
\end_layout

\begin_layout Plain Layout

            ohlc_df = pd.DataFrame(ohlc_data, columns=["Time", "Open", "High",
 "Low", 
\end_layout

\begin_layout Plain Layout

                      "Close", "VWAP", "Volume", "Count"]).drop(['VWAP',
 'Count'], axis=1)
\end_layout

\begin_layout Plain Layout

            
\end_layout

\begin_layout Plain Layout

            # Convert timestamps to datetime format and set as DataFrame
 index             
\end_layout

\begin_layout Plain Layout

            ohlc_df["Time"] = pd.to_datetime(ohlc_df["Time"], unit='s') 
           
\end_layout

\begin_layout Plain Layout

            ohlc_df.set_index(pd.DatetimeIndex(ohlc_df["Time"]), inplace=True)
             
\end_layout

\begin_layout Plain Layout

            if self.until is not None:    # Filter data when until is not
 None                
\end_layout

\begin_layout Plain Layout

                cutoff_date = pd.to_datetime(self.until, unit='s')       
          
\end_layout

\begin_layout Plain Layout

                ohlc_df = ohlc_df[ohlc_df.index < cutoff_date]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

            # Convert all price and volume data to float type for calculations
             
\end_layout

\begin_layout Plain Layout

            ohlc_df["Open"] = ohlc_df["Open"].astype(float)       
\end_layout

\begin_layout Plain Layout

            ohlc_df["High"] = ohlc_df["High"].astype(float)             
       
\end_layout

\begin_layout Plain Layout

            ohlc_df["Low"] = ohlc_df["Low"].astype(float)               
       
\end_layout

\begin_layout Plain Layout

            ohlc_df["Close"] = ohlc_df["Close"].astype(float)           
       
\end_layout

\begin_layout Plain Layout

            ohlc_df["Volume"] = ohlc_df["Volume"].astype(float)   
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

            # Add Simple Moving Average (SMA) and Exponential Moving Average
 (EMA)            
\end_layout

\begin_layout Plain Layout

            window = 14 if ohlc_df.shape[0] >= 60 else 3               
\end_layout

\begin_layout Plain Layout

            ohlc_df['SMA'] = ohlc_df['Close'].rolling(window=window).mean()
             
\end_layout

\begin_layout Plain Layout

            ohlc_df['EMA'] = ohlc_df['Close'].ewm(span=window, adjust=False).mean(
)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

            # Aggregate data into custom intervals if needed           
  
\end_layout

\begin_layout Plain Layout

            if self.interval not in (1, 5, 15, 30, 60, 240, 1440, 10080,
 21600):                 
\end_layout

\begin_layout Plain Layout

                ohlc_df = self.aggregate_intervals(ohlc_df)             
\end_layout

\begin_layout Plain Layout

            return ohlc_df  # Return the prepared DataFrame
\end_layout

\begin_layout Plain Layout


\backslash
end{python}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Por último, aplicamos la función de agregación cuando el intervalo seleccionado
 por el usuario no se encuentre entre las opciones disponibles para realizar
 una consulta directa a la API de Kraken.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{python}
\end_layout

\begin_layout Plain Layout

# insertar el código
\end_layout

\begin_layout Plain Layout


\backslash
end{python}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Grabado de las cotizaciones
\end_layout

\begin_layout Standard
Las cotizaciones de un par de divisas suelen ser representadas haciendo
 uso de un gráfico de velas para la información OHLC (Open - High - Low
 - Close).
 Para llevar a cabo esta representación creamos una figura candlestick con
 plotly, a partir de los datos obtenidos en la consulta a la API de Kraken.
 Adicionalmente, hemos incluido la información del volumen a lo largo del
 tiempo con un diagrama de barras que refleja el número de transacciones
 para el intervalo de cada vela y el cambio en el precio con el mismo color
 que la vela pero con una opacidad menor para que ambas gráficas puedan
 coexistir y complementarse.
 Por otro lado, hemos tenido en cuenta la información de cierre para añadir
 sendos diagramas de líneas que representen los indicadores SMA y EMA.
 
\series bold
\color violet
(explicar la ventana escogida para el rolling y la manera de calcular el
 EMA)
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{python}
\end_layout

\begin_layout Plain Layout

# insertar el código del cálculo de SMA y EMA
\end_layout

\begin_layout Plain Layout

# insertar el código de la figura candlestick
\end_layout

\begin_layout Plain Layout

# añadir una captura de como se vería la cotización
\end_layout

\begin_layout Plain Layout


\backslash
end{python}
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
\color violet
Calculadora de ganancias.
 Damos tambien la opción de hacer una pequeña simulación utilizando los
 datos que vemos en las graficas.
 Para ello cogemos las señales de compra y simulamos una cartera en la que
 compramos 100 unidades de la moneda por señal y vendemos 100 unidades por
 cada señal de venta.
 La grafica representa las ganancias o perdidas que se tendrian en el periodo.
 No se muestra ninguna grafica si no se han generado señales de compra en
 el periodo.
\end_layout

\begin_layout Section
Indicadores técnicos
\end_layout

\begin_layout Standard

\series bold
\color violet
(añadir descripción) 
\series default
\color inherit
Como ya hemos explicado en el apartado anterior, se han calculado y representado
 en el gráfico de velas los indicadores SMA (Simple Moving Average) y EMA
 (Exponential Moving Average).
 Sin embargo, el indicador principal de esta práctica ha sido el oscilador
 estocásatica, el cual explicaremos a continuación como ha sido calculado
 y su representación gráfica en la aplicación creada.
\end_layout

\begin_layout Subsection
Cálculo y representación gráfica del oscilador estocástico
\end_layout

\begin_layout Standard
El estocástico es un indicador de momentum desarrollado en los años 50.Se
 utiliza para mostrar la ubicación del cierre actual en relación con el
 rango alto/bajo durante un número determinado de períodos.La fórmula para
 calcular el estocástico es la siguiente:
\begin_inset Formula %K=(Preciodecierreactual-Mínimomásbajo)/(Máximomásalto-Mínimomásbajo)*100

\end_inset

Donde:- Precio de cierre actual: es el último precio al que se negoció un
 activo.- Mínimo más bajo: es el precio más bajo negociado del activo durante
 un período determinado.- Máximo más alto: es el precio más alto negociado
 del activo durante un período determinado.El estocástico se representa con
 dos líneas, %K y %D.
 La línea %D es una media móvil de %K.Cuando la línea %K cruza por encima
 de la línea %D, se genera una señal de compra.
 Cuando la línea %K cruza por debajo de la línea %D, se genera una señal
 de venta.
 TODO comprimir este parrafo a una o dos frases o borrar directamente
\end_layout

\begin_layout Standard
Explicación de nuestra forma de calcularlo: Primero, calcula el oscilador
 estocástico (%K) y su media móvil (%D) utilizando los precios de cierre,
 alto y bajo de un DataFrame de pandas.
 Luego, genera señales de compra y venta basadas en las condiciones especificada
s en las líneas 117 y 118.
\end_layout

\begin_layout Standard
La fórmula (df['Close'] - df['L14']) / (df['H14'] - df['L14']) * 100 es
 la implementación de la fórmula del oscilador estocásticoque mide la relación
 entre el precio de cierre actual y el rango de precios en un número determinado
 de períodos.
\end_layout

\begin_layout Standard
La línea df['%D'] = df['%K'].rolling(window=3).mean() calcula la media móvil
 de 3 períodos de %K, que se conoce como %D.
 La media móvil se utiliza para suavizar las fluctuaciones de %K y generar
 una línea de señal para las señales de compra y venta.
\end_layout

\begin_layout Standard
Tambien generamos las señales de compra y venta que utilizaremos en la simulacio
n de beneficios.
\end_layout

\begin_layout Itemize
Las de compra se generan cuando la línea %K cruza por encima de la línea
 %D y el valor de %D es menor que 20
\end_layout

\begin_layout Itemize
Las de venta se generan cuando la línea %K cruza por debajo de la línea
 %D y el valor de %D es mayor que 80
\end_layout

\begin_layout Subsection
Cálculo del oscilador estocástico sobre una media móvil
\end_layout

\begin_layout Subsection
Gráfico del indicador junto con la cotización del par calculado
\end_layout

\begin_layout Standard
Graficar los dos juntos
\end_layout

\begin_layout Standard
Finalmente damos al usuario la opción de graficar las anteriores opciones
 juntas.
 TODO captura gráficas juntas
\end_layout

\begin_layout Standard
Adicionalmente aquí damos la opción de simular ganancias que será explciada
 en su sección más adelante TODO es esta línea necesaria?
\end_layout

\begin_layout Standard
(a) Media móvil exponencial
\end_layout

\begin_layout Standard
Es otro tipo de media movil que da mas peso a los datos mas recientes, lo
 que hace que sea mas sensibles a cambios a corto plazo.
 TODO confirmame que esto es correcto?
\end_layout

\begin_layout Standard
(b) Media móvil simple
\end_layout

\begin_layout Standard
TODO tenemos esto siquiera?, no es el smoothed stochastic oscillator?
\end_layout

\begin_layout Section
Estructuración
\end_layout

\begin_layout Standard

\series bold
\color violet
(añadir descripción)
\end_layout

\begin_layout Subsection
Funciones
\end_layout

\begin_layout Subsection
Utilización de clases
\end_layout

\begin_layout Subsection
Manejo de errores y excepciones
\end_layout

\begin_layout Section
Puntuación Extra
\end_layout

\begin_layout Standard

\series bold
\color violet
(añadir descripción)
\end_layout

\begin_layout Subsection
Testeo y cobertura (unit-testing, integration-testing)
\end_layout

\begin_layout Standard
Durante todo el proceso hemos buscado evitar casos que puedan dar pie a
 errores por incongruencia con el tipado de las variables o la no selección
 de alguno de los atributos necesarios par el cálculo de los distintos tipos
 de gráficas.
\end_layout

\begin_layout Subsection
Facilitar los mecanismos para la reproducción del entorno virtual
\end_layout

\begin_layout Subsection
Distribución del proyecto a través de PyPi
\end_layout

\end_body
\end_document
