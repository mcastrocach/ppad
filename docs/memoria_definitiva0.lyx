#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass article
\begin_preamble
\date{}

% Default fixed font does not support bold face
\DeclareFixedFont{\ttb}{T1}{txtt}{bx}{n}{10} % for bold
\DeclareFixedFont{\ttm}{T1}{txtt}{m}{n}{10}  % for normal

% Custom colors
\usepackage{color}
\definecolor{deepblue}{rgb}{0,0,0.5}
\definecolor{deepred}{rgb}{0.6,0,0}
\definecolor{deepgreen}{rgb}{0,0.5,0}

\usepackage{listings}

% Python style for highlighting
\newcommand\pythonstyle{\lstset{
language=Python,
basicstyle=\ttm,
morekeywords={self, with},              % Add keywords here
keywordstyle=\ttb\color{deepblue},
emph={MyClass,__init__},          % Custom highlighting
emphstyle=\ttb\color{deepred},    % Custom highlighting style
stringstyle=\color{deepgreen},
frame=tb,                         % Any extra options here
showstringspaces=false
}}


% Python environment
\lstnewenvironment{python}[1][]
{
\pythonstyle
\lstset{#1}
}
{}

% Python for external files
\newcommand\pythonexternal[2][]{{
\pythonstyle
\lstinputlisting[#1]{#2}}}

% Python for inline
\newcommand\pythoninline[1]{{\pythonstyle\lstinline!#1!}}
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 2.5cm
\topmargin 3cm
\rightmargin 2.5cm
\bottommargin 3cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation 0bp
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard

\series bold
\size largest
Python para el Análisis de Datos.
 Proyecto Final (MEBDS)
\end_layout

\begin_layout Standard
\align center
Realizado por
\emph on
: Rodrigo de la Nuez Moraleda 
\emph default
y
\emph on
 Marcos Castro Cacho
\end_layout

\begin_layout Standard
\begin_inset VSpace 15bp
\end_inset


\end_layout

\begin_layout Standard

\series bold
\color teal
Descripción de 
\bar under
cómo
\bar default
 se ha afrontado el proyecto y 
\bar under
por qué
\bar default
.
\end_layout

\begin_layout Standard
Este proyecto se ha llevado a cabo con el objetivo de aplicar y profundizar
 en los conocimientos adquiridos en la asignatura 
\shape italic
Python para el Análisis de Datos
\shape default
.
 Combinando el aprendizaje académico con nuestra propia investigación de
 librerías y herramientas externas, hemos creado una aplicación que permite
 analizar datos reales y actualizados de los precios de distintos pares
 de divisas.
\begin_inset Newline newline
\end_inset

 
\end_layout

\begin_layout Standard
Para ello se ha creado una interfaz interactiva que permite crear un gráfico
 de velas, junto con varios indicadores bursátiles, a partir de la información
 OHLC de un par de divisas específico, el intervalo de tiempo usado para
 la agregación y, opcionalmente, un marco temporal que acote los resultados.
 
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
El proceso que se ha seguido para afrontar el proyecto y llevar a cabo el
 desarrollo del programa creado se puede dividir en varias fases.
 En primer lugar, estudiamos los datos devueltos por la API de Kraken para
 el par ETH/USDT con el objetivo de comprender la estructura de los mismos,
 así como la mejor manera de manipularlos para lograr nuestros objetivos.
 Tras ello, utilizamos 
\shape italic
webscraping
\shape default
 para obtener todos los pares de divisas disponibles en la API y tener capacidad
 de elección entre estas opciones.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Para la representación gráfica de la cotización de las divisas y los indicadores
 calculados, se hicieron pruebas con distintas librerías (
\family typewriter
matplotlib
\family default
, 
\family typewriter
mplfinance
\family default
); pero finalmente optamos por utilizar 
\family typewriter
plotly
\family default
 para ello.
 Por último, estudiamos como utilizar 
\family typewriter
streamlit
\family default
 para ofrecer al usuario una experiencia interactiva.
 Tras este punto, centramos nuestros esfuerzos en refinar nuestro código
 (añadir nuevas funcionalidades, mejorar el proceso y la estructura, comentar
 su funcionamiento, etc.), agregar pruebas que nos permitan evaluar la corrección
 de nuestro programa, estudiar la reproducción de nuestro entorno a través
 de distintas herramientas y documentar de todo el proceso en esta memoria.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard

\series bold
\color teal
Descripción de la 
\bar under
estructura del código
\bar default
 y 
\bar under
estructura de ficheros
\bar default
.
\end_layout

\begin_layout Standard
Nuestro programa necesita de tres ficheros distintos para su correcta ejecución:
\end_layout

\begin_layout Itemize

\family typewriter
graphs.py
\family default
, que contiene la 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
pythoninline{class Graph}
\end_layout

\end_inset

 con métodos para la obtención de los datos y la representación gráfica
 de los mismos (junto con los indicadores asociados), según el par de divisas,
 el intervalo de agregación y el marco temporal seleccionados.
\end_layout

\begin_layout Itemize

\family typewriter
front.py
\family default
, que contiene la 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
pythoninline{class Front}
\end_layout

\end_inset

.
 Esta crea la interaz de usuario con la que se puede interactuar, de forma
 que la información mostrada coincida con la seleccionada, haciendo uso
 de los 
\shape italic
widgets
\shape default
 y botones que 
\family typewriter
streamlit
\family default
 proporciona para la rápida y fácil creación de aplicaciones web.
\end_layout

\begin_layout Itemize

\family typewriter
main.py
\family default
, que contiene el código necesario para la ejecución de la aplicación.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Estos ficheros deben encontrarse en el mismo directorio para que el programa
 pueda acceder a las distintas funcionalidades que han sido creadas sin
 la aparición de excepciones.
 Contamos, además, con un fichero 
\family typewriter
tests.py
\family default
 para la ejecución de las pruebas de software creadas; un fichero 
\family typewriter
requirements.txt
\family default
 para poder instalar fácilmente todas las librerías necesarias, con las
 versiones adecuadas.
 para la ejecución del código; un fichero 
\family typewriter
setup.py
\family default
 
\series bold
\color violet
(añadir descripción)
\series default
\color inherit
 y un fichero 
\family typewriter
dockerfile
\family default
 
\series bold
\color violet
(añadir descripción)
\series default
\color inherit
.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard

\series bold
\color teal
Descripción de la 
\bar under
forma de ejecución del código
\bar default
.
\end_layout

\begin_layout Standard
El comando 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
pythoninline{streamlit run main.py}
\end_layout

\end_inset

 permite la ejecución del programa desde su directorio.
\end_layout

\begin_layout Standard
Se puede acceder a la aplicacion directamente en 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
pythoninline{https://l3vhpftnhq75225rcpsappc.streamlit.app}
\end_layout

\end_inset

.
\end_layout

\begin_layout Section
Lectura y representación del movimiento del par de monedas
\end_layout

\begin_layout Standard

\series bold
\color violet
(añadir descripción)
\end_layout

\begin_layout Subsection
Descarga de los datos
\end_layout

\begin_layout Standard
Para la descarga de los datos contábamos con las siguientes posibilidades:
 utilizar la librería 
\family typewriter
krakenex
\family default
, hacer una descarga directa a través de 
\family typewriter
pandas
\family default
 o descargar directamente el 
\family typewriter
.csv
\family default
 y utilizar el archivo de forma local.
 
\end_layout

\begin_layout Standard
Debido a que de estas tres opciones la única que permite recoger información
 de distintos pares de divisas para crear una herramienta interactiva es
 la primera de ellas, nuestro programa lleva a cabo esta fase del proceso
 a través de una consulta a la API de Kraken usando la librería 
\family typewriter
krakenex
\family default
.
\begin_inset Newline newline
\end_inset

 
\end_layout

\begin_layout Standard
En la 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
pythoninline{class Graph}
\end_layout

\end_inset

 del fichero 
\family typewriter
graphs.py
\family default
, inicializamos el cliente de Kraken para hacer una llamada al endpoint
 publico OHLC con la función 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
pythoninline{def obtain_data(self)}
\end_layout

\end_inset

 y almacenamos en un dataframe de 
\family typewriter
pandas
\family default
 toda la información recogida en la consulta para la selección escogida
 por el usuario.
 
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Esta clase se inicializa como se muestra en el siguiente fragmento del código:
\begin_inset VSpace 5bp
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{python}
\end_layout

\begin_layout Plain Layout

class Graph:
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    # Constructor for initializing a Graph instance
\end_layout

\begin_layout Plain Layout

    def __init__(self, pair='XETHZUSD', interval=1440, divisor=1, 
\end_layout

\begin_layout Plain Layout

                       since=None, until=None):
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        self.pair = pair          # The currency pair to be analyzed    
     
\end_layout

\begin_layout Plain Layout

        self.interval = interval  # Time interval for each data point in
 minutes         
\end_layout

\begin_layout Plain Layout

        self.divisor = divisor    # Divisor for interval adjustment     
    
\end_layout

\begin_layout Plain Layout

        self.since = since        # Start of the time window        
\end_layout

\begin_layout Plain Layout

        self.until = until        # Time limit for the time window
\end_layout

\begin_layout Plain Layout


\backslash
end{python}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace 25bp
\end_inset


\end_layout

\begin_layout Standard
Para la obtención de datos a través de la consulta a la API, se requieren
 los siguientes argumentos:
\end_layout

\begin_layout Itemize

\family typewriter
pair
\family default
.
 Denota el identificador del par de divisas para el cual se extraerán datos.
 Para ofrecer al usuario la posibilidad de elegir entre todos los pares
 de divisas para los que Kraken tiene información, hemos usado la librería
 
\family typewriter
requests
\family default
 para crear en 
\family typewriter
front.py
\family default
 una función 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
pythoninline{def get_kraken_pairs()}
\end_layout

\end_inset

 que guarda en la tupla 
\family typewriter
kraken_pairs
\family default
 todos los pares de divisas disponibles a través del endpoint público 
\bar under
\color cyan

\begin_inset CommandInset href
LatexCommand href
name "AssetPairs"
target "https://api.kraken.com/0/public/AssetPairs"
literal "false"

\end_inset


\bar default
\color inherit
.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{python}
\end_layout

\begin_layout Plain Layout

# Import the requests library for HTTP request handling
\end_layout

\begin_layout Plain Layout

import requests  
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Retrieves all available currency pairs from the Kraken API 
\end_layout

\begin_layout Plain Layout

def get_kraken_pairs():
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    # Endpoint URL for fetching Kraken currency pairs  
\end_layout

\begin_layout Plain Layout

    url = 'https://api.kraken.com/0/public/AssetPairs'
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    # Send a GET request to the Kraken API       
\end_layout

\begin_layout Plain Layout

    response = requests.get(url)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    # Convert the response to JSON format                            
\end_layout

\begin_layout Plain Layout

    response_json = response.json()
\end_layout

\begin_layout Plain Layout

    # Extract currency pair identifiers from the JSON data             
         
\end_layout

\begin_layout Plain Layout

    pairs = response_json['result'].keys()
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    # Return the currency pairs as a tuple                
\end_layout

\begin_layout Plain Layout

    return tuple(pairs)                                 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Get and store the list of currency pairs available on Kraken
\end_layout

\begin_layout Plain Layout

kraken_pairs = get_kraken_pairs()  
\end_layout

\begin_layout Plain Layout


\backslash
end{python}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace 20bp
\end_inset

Para seleccionar un par de divisas de entre los disponibles, hemos utilizado
 
\family typewriter
streamlit
\family default
 para generar un menú dropdown en la aplicación (importamos esta librería
 como sigue: 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
pythoninline{import streamlit as st}
\end_layout

\end_inset

).
\begin_inset VSpace 5bp
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{python}
\end_layout

\begin_layout Plain Layout

class Front:
\end_layout

\begin_layout Plain Layout

    [...]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    # Method to create user input interfaces, including dropdowns and buttons
\end_layout

\begin_layout Plain Layout

    def select_boxes(self):
\end_layout

\begin_layout Plain Layout

        # Prompt user to select a currency pair from the pairs retrieved
         
\end_layout

\begin_layout Plain Layout

        st.write("1.
 Please select a currency pair from the available options:")
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        # Dropdown menu for selecting a currency pair         
\end_layout

\begin_layout Plain Layout

        self.currency_pair = st.selectbox(           
\end_layout

\begin_layout Plain Layout

            label = 'placeholder',         # Streamlit's selectbox requires
 a label           
\end_layout

\begin_layout Plain Layout

            options = kraken_pairs,        # List of currency pairs from
 Kraken            
\end_layout

\begin_layout Plain Layout

            index = None,                  # Index of the preselected option
\end_layout

\begin_layout Plain Layout

            placeholder = "xxxxxxx",       # Placeholder text in the dropdown
            
\end_layout

\begin_layout Plain Layout

            label_visibility = "collapsed"         
\end_layout

\begin_layout Plain Layout

        )
\end_layout

\begin_layout Plain Layout


\backslash
end{python}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace 20bp
\end_inset


\end_layout

\begin_layout Standard
Así se vería el menú dropdown en la aplicación creada con 
\family typewriter
streamlit
\family default
:
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename dropdown_menu.JPG
	scale 75

\end_inset


\begin_inset VSpace 20bp
\end_inset


\end_layout

\begin_layout Itemize

\family typewriter
interval
\family default
.
 Denota el intervalo de tiempo (en minutos) que se utiliza para la agregación,
 es decir, cada vela del gráfico generado contará con datos de tantos minutos
 como el valor de 
\family typewriter
interval
\family default
.
 Para este atributo ofrecemos dos opciones al usuario: seleccionar entre
 los intervalos de tiempo más comunes (para los que 
\family typewriter
krakenex
\family default
 ofrece datos con una consulta directa y así se indica en la 
\bar under
\color cyan

\begin_inset CommandInset href
LatexCommand href
name "documentación"
target "https://docs.kraken.com/rest/#tag/Market-Data/operation/getOHLCData"
literal "false"

\end_inset


\bar default
\color inherit
) o escribir el valor del intervalo que desea seleccionar como un número
 entero entre 1 y 43200 (1 mes).
 
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{python}
\end_layout

\begin_layout Plain Layout

# A dictionary mapping time intervals to their durations in minutes 
\end_layout

\begin_layout Plain Layout

intervals = {"1m":1, "5m":5, "15m":15, "30m":30, "1h":60, "4h":240,
\end_layout

\begin_layout Plain Layout

             "1d":1440, "1w":10080, "2w":21600} 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Separate lists of interval labels and their corresponding durations
\end_layout

\begin_layout Plain Layout

keys, options = intervals.keys(), intervals.values()  
\end_layout

\begin_layout Plain Layout


\backslash
end{python}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace 10bp
\end_inset

Si el intervalo toma un valor a elección del usuario, utilizamos la función
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
pythoninline{def find_largest_interval(n)}
\end_layout

\end_inset

 en 
\family typewriter
front.py
\family default
 para realizar la consulta con el mayor divisor de entre los intervalos
 predeterminados del entero introducido.
 La función 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
pythoninline{def aggregate_intervals(interval, df)}
\end_layout

\end_inset

 en 
\family typewriter
graphs.py
\family default
 permite la agregación de los distintos campos según el intervalo que el
 usuario ha seleccionado desde la aplicación.
\begin_inset VSpace 5bp
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{python}
\end_layout

\begin_layout Plain Layout

# Finds the largest duration in 'options' that is a divisor of n 
\end_layout

\begin_layout Plain Layout

def find_largest_divisor(n):  
\end_layout

\begin_layout Plain Layout

    # Filters durations that are divisors of n  
\end_layout

\begin_layout Plain Layout

    valid_divisors = [d for d in options if n % d == 0] 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    # Returns the largest divisor found  
\end_layout

\begin_layout Plain Layout

    return max(valid_divisors)                            
\end_layout

\begin_layout Plain Layout


\backslash
end{python}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace 15bp
\end_inset

Llevamos a cabo este proceso ya que la consulta a la API de Kraken solamente
 acepta los intervalos de 
\family typewriter
options
\family default
 y devuelve una respuesta con un límite de tamaño de 720 intervalos por
 consulta, por lo que buscamos el intervalo que nos permita contar con más
 información tras la agregación.
 Debido a esta limitación, al realizar ciertas agregaciones obtendremos
 unos pocos valores en nuestras gráficas.
 Este problema se podría solucionar realizando múltiples consultas a la
 API y juntando las respuestas a las distintas consultas antes de realizar
 la agregación.
 Sin embargo, esto no es posible pues, al hacer varias consultas de forma
 muy seguida, recogemos el siguiente mensaje de error que indica que se
 han realizado demasiadas consultas a la API.
\begin_inset VSpace 5bp
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{python}
\end_layout

\begin_layout Plain Layout

There was an error with the API call 
\end_layout

\begin_layout Plain Layout

An error occurred: ['EGeneral:Too many requests']
\end_layout

\begin_layout Plain Layout


\backslash
end{python}
\end_layout

\end_inset


\begin_inset VSpace 15bp
\end_inset


\end_layout

\begin_layout Standard
Para la selección del intervalo entre las distintas opciones, hemos creado
 un conjunto de botones y un objeto 
\family typewriter
number_input
\family default
 de 
\family typewriter
streamlit
\family default
 que únicamente acepta números enteros entre 1 y 43200 (ambos incluidos).
 Además, utilizamos el diccionario 
\family typewriter
st.session_state
\family default
 para almacenar la selección del intervalo y que no se pierda su valor a
 lo largo del tiempo en la aplicación de 
\family typewriter
streamlit
\family default
 creada.
\begin_inset VSpace 5bp
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{python}
\end_layout

\begin_layout Plain Layout

class Front:
\end_layout

\begin_layout Plain Layout

    def __init__(self):
\end_layout

\begin_layout Plain Layout

        [...]
\end_layout

\begin_layout Plain Layout

        # Retrieve or initialize the selected time interval for each candle
\end_layout

\begin_layout Plain Layout

        st.session_state['selected_option'] = 
\end_layout

\begin_layout Plain Layout

                               st.session_state.get("selected_option", None)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        st.session_state['is_custom_interval'] = 
\end_layout

\begin_layout Plain Layout

                            st.session_state.get("is_custom_interval", None)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        # Retrieve or initialize the customized time interval for each candle
\end_layout

\begin_layout Plain Layout

        st.session_state['custom_interval'] = 
\end_layout

\begin_layout Plain Layout

                            st.session_state.get("custom_interval", None)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        # Store the time interval for each candle from the session state
\end_layout

\begin_layout Plain Layout

        self.time_interval = st.session_state['selected_option']  
\end_layout

\begin_layout Plain Layout

        [...] 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    def select_boxes(self):
\end_layout

\begin_layout Plain Layout

        [...]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        st.markdown("2.
 Choose a time interval for the candles from 
\end_layout

\begin_layout Plain Layout

                                     the most commonly used options..." + 
             
\end_layout

\begin_layout Plain Layout

            f"""             
\end_layout

\begin_layout Plain Layout

            <style>             
\end_layout

\begin_layout Plain Layout

            div.stButton > button {{                 
\end_layout

\begin_layout Plain Layout

                width: 100%;             
\end_layout

\begin_layout Plain Layout

            }}             
\end_layout

\begin_layout Plain Layout

            </style>""", unsafe_allow_html=True )                  
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        # Generate a row of buttons for selecting time intervals       
  
\end_layout

\begin_layout Plain Layout

        columns = st.columns(len(keys))         
\end_layout

\begin_layout Plain Layout

        for i, key in enumerate(keys):             
\end_layout

\begin_layout Plain Layout

            with columns[i]:                 
\end_layout

\begin_layout Plain Layout

                button_key = f"button-{key}"                 
\end_layout

\begin_layout Plain Layout

                if st.button(key, key=button_key):
\end_layout

\begin_layout Plain Layout

                    # Sets the selected time interval
\end_layout

\begin_layout Plain Layout

                    self.time_interval = int(intervals[key])
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

                    # Updates the different values stored in the session
 state                                   
\end_layout

\begin_layout Plain Layout

                    st.session_state['selected_option'] = self.time_interval
\end_layout

\begin_layout Plain Layout

                    st.session_state['is_custom_interval'] = None       
              
\end_layout

\begin_layout Plain Layout

                    st.session_state['custom_interval'] = None 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        # Button for allowing custom time interval input         
\end_layout

\begin_layout Plain Layout

        if st.button("...or enter a custom time interval (in minutes)", key="Other")
:                          
\end_layout

\begin_layout Plain Layout

            st.session_state['is_custom_interval'] = 
\end_layout

\begin_layout Plain Layout

                                           not st.session_state['is_custom_interv
al']
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        # Input field for custom time interval in minutes
\end_layout

\begin_layout Plain Layout

        if st.session_state['is_custom_interval']:             
\end_layout

\begin_layout Plain Layout

            st.session_state['custom_interval'] = st.number_input('Custom
 interval', 
\end_layout

\begin_layout Plain Layout

                min_value=1, max_value=43200, step=1, 
\end_layout

\begin_layout Plain Layout

                value=None, label_visibility='collapsed')              
        
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        # Update the time interval with the custom input
\end_layout

\begin_layout Plain Layout

        if st.session_state['custom_interval'] is not None:             
 
\end_layout

\begin_layout Plain Layout

            self.time_interval = st.session_state['custom_interval'] 
\end_layout

\begin_layout Plain Layout

            st.session_state['selected_option'] = st.session_state['custom_interva
l'] 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        [...]
\end_layout

\begin_layout Plain Layout


\backslash
end{python}
\end_layout

\end_inset


\begin_inset Newpage pagebreak
\end_inset

Así se verían el conjunto de botones y el 
\family typewriter
number_input
\family default
 en la aplicación creada con 
\family typewriter
streamlit
\family default
:
\begin_inset VSpace 5bp
\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename time_buttons.JPG
	scale 85

\end_inset


\begin_inset VSpace 15bp
\end_inset


\end_layout

\begin_layout Itemize

\family typewriter
since
\family default
.
 Denota el tiempo para el cual se toman los primeros datos en la consulta,es
 un número entero que se corresponde con un timestamp de Unix.
 Este valor es el el número de segundos transcurridos desde la medianoche
 UTC del 1 de enero de 1970.
 Por ejemplo, el timestamp Unix "1548111600" se correspondería con la fecha
 y hora "2019-01-21 23:00:00 UTC".
 Cabe destacar que si el tiempo introducido es anterior al primero de los
 720 intervalos devueltos por la API, esta funcionalidad no empezará en
 el tiempo indicado sino en el primero de esos 720 intervalos.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Además, hemos buscado acotar la última fecha para la que se muestran datos
 y, dado que 
\family typewriter
krakenex
\family default
 no cuenta con dicha funcionalidad, hemos añadido un atributo 
\family typewriter
until
\family default
 a la 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
pythoninline{class Graph}
\end_layout

\end_inset

 con el que aplicamos un filtro tras la obtención de los datos.
 Para la selección de los valores de 
\family typewriter
since
\family default
 y 
\family typewriter
until
\family default
, hemos usado las funcionalidades de 
\family typewriter
streamlit
\family default
 para crear dos objetos 
\family typewriter
expander
\family default
 con un 
\family typewriter
date_input
\family default
 cada uno.
\begin_inset VSpace 5bp
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{python}
\end_layout

\begin_layout Plain Layout

class Front:
\end_layout

\begin_layout Plain Layout

    def __init__(self):
\end_layout

\begin_layout Plain Layout

        [...]                                 
\end_layout

\begin_layout Plain Layout

        # Initialize since and until attributes
\end_layout

\begin_layout Plain Layout

        self.since, self.until = None, None
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    def select_boxes(self):
\end_layout

\begin_layout Plain Layout

        [...]
\end_layout

\begin_layout Plain Layout

        st.markdown("3.
 Optionally, choose a time window within 
\end_layout

\begin_layout Plain Layout

                              the range of the original selection:")   
               
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        # Date picker for selecting the start date         
\end_layout

\begin_layout Plain Layout

        columns0, columns1 = st.columns([1, 1])         
\end_layout

\begin_layout Plain Layout

        with columns0:             
\end_layout

\begin_layout Plain Layout

            with st.expander("Start Date", expanded=True):              
   
\end_layout

\begin_layout Plain Layout

                self.since = st.date_input('start', value=None, 
\end_layout

\begin_layout Plain Layout

                                           label_visibility = "collapsed")
                 
\end_layout

\begin_layout Plain Layout

                if self.since is not None:                     
\end_layout

\begin_layout Plain Layout

                    # Convert date to datetime                     
\end_layout

\begin_layout Plain Layout

                    self.since = datetime.datetime.combine(self.since, 
\end_layout

\begin_layout Plain Layout

                                                datetime.datetime.min.time())
                     
\end_layout

\begin_layout Plain Layout

                    self.since = datetime.datetime.strptime(str(self.since),
 
\end_layout

\begin_layout Plain Layout

                                             "%Y-%m-%d %H:%M:%S").timestamp()
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        with columns1:             
\end_layout

\begin_layout Plain Layout

            with st.expander("End Date", expanded=True):                
 
\end_layout

\begin_layout Plain Layout

                self.until = st.date_input('end', value=None, 
\end_layout

\begin_layout Plain Layout

                                           label_visibility = "collapsed")
                 
\end_layout

\begin_layout Plain Layout

                if self.until is not None:                     
\end_layout

\begin_layout Plain Layout

                    # Convert date to datetime                     
\end_layout

\begin_layout Plain Layout

                    self.until = datetime.datetime.combine(self.until, 
\end_layout

\begin_layout Plain Layout

                                                datetime.datetime.min.time())
\end_layout

\begin_layout Plain Layout

                    self.until = datetime.datetime.strptime(str(self.until),
 
\end_layout

\begin_layout Plain Layout

                                             "%Y-%m-%d %H:%M:%S").timestamp()
\end_layout

\begin_layout Plain Layout


\backslash
end{python}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace 5bp
\end_inset

Así se verían los objetos 
\family typewriter
expander
\family default
 con el 
\family typewriter
date_input
\family default
 en la aplicación creada con 
\family typewriter
streamlit
\family default
:
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename since_until.JPG
	scale 85

\end_inset


\begin_inset VSpace 5bp
\end_inset


\end_layout

\begin_layout Standard
Con los inputs mencionados, en 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
pythoninline{def obtain_function(pair, interval, divisor, since, until)}
\end_layout

\end_inset

 se lle- va a cabo la consulta con la que se recuperan los datos en formato
 JSON, con dos campos 
\family typewriter
response
\family default
 y 
\family typewriter
error
\family default
.
 En caso de haber algún problema con la llamada a la API, se recoge la excepción
 en el campo 
\family typewriter
error
\family default
 y, de no ser así, el campo 
\family typewriter
response
\family default
 a su vez guarda la información de los campos 
\family typewriter
Time
\family default
 (tiempo de apertura del intervalo), 
\family typewriter
Open
\family default
 (precio de apertura del intervalo), 
\family typewriter
High
\family default
 (precio más alto del intervalo), 
\family typewriter
Low
\family default
 (precio más bajo del intervalo), 
\family typewriter
Close
\family default
 (precio de cierre del intervalo), 
\family typewriter
VWAP
\family default
 (valor del indicador para el intervalo), 
\family typewriter
Volume
\family default
 (volumen acumulado del intervalo) y 
\family typewriter
Count
\family default
 (número de transacciones en el intervalo).
 Nótese que utilizamos el decorador 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
pythoninline{@st.cache_data(ttl=300)}
\end_layout

\end_inset

 para guardar el resultado de esta función en la caché de streamlit durante
 5 minutos y así no repetir innecesariamente procesos que ya se han realizado
 con antelación.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Transformamos los datos a un dataframe de 
\family typewriter
pandas
\family default
 y prescindimos de los campos 
\family typewriter
VWAP
\family default
 y 
\family typewriter
Count
\family default
, pues no nos son de utilidad.
 Cambiamos los timestamps de Unix al tipo 
\family typewriter
datetime
\family default
 de 
\family typewriter
pandas
\family default
, usamos el campo 
\family typewriter
Time
\family default
 como índice del dataframe, filtramos los datos cuando se haya introducido
 un valor para 
\family typewriter
until
\family default
 y transformamos el tipo del resto de campos de 
\family typewriter
float
\family default
 a 
\family typewriter
string
\family default
.
 
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
A continuación, se han calculado dos indicadores bursátiles para su inclusión
 en el gráfico de velas: el SMA o 
\end_layout

\begin_layout Standard

\shape italic
Simple Moving Average
\shape default
 (media móvil del precio de cierre) y el EMA o 
\shape italic
Exponential Moving Average
\shape default
 (similar al SMA pero dando más peso a los datos mas recientes, lo que hace
 que sea más sensible a cambios a corto plazo).
 
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
En el cálculo de medias móviles, como es este caso, existe la convención
 de escoger una ventana de 14 intervalos y, aunque esta elección puede variar
 según el análisis que se busque hacer sobre los datos, hemos decidido adoptar
 este estándar para nuestra aplicación.
 No obstante, hemos tenido en cuenta casos en los que la consulta no devuelve
 datos para muchos intervalos y, en tal escenario, se toma una ventana de
 únicamente 3 intervalos para poder calcular los indicadores en un mayor
 porcentaje de los intervalos obtenidos.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Por último, aplicamos la función 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
pythoninline{def aggregate_intervals(interval, df)}
\end_layout

\end_inset

 cuando el intervalo seleccionado por el usuario no se encuentre entre las
 opciones disponibles para realizar una consulta directa a la API de Kraken.
 Además, guardamos los campos necesarios para el cálculo del oscilador estocásti
co, la media móvil de este indicador y las señales de compra y venta para
 una estrategia de trading que hemos definido.
 Estos últimos campos serán explicados más adelante en sus respectivas secciones.
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{python}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# This function aggregates data into custom time intervals 
\end_layout

\begin_layout Plain Layout

#  that are not natively provided by the Kraken API to make queries   
\end_layout

\begin_layout Plain Layout

def aggregate_intervals(interval, df):      
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

    # Resamples the DataFrame to the specified interval and aggregates key
 metrics         
\end_layout

\begin_layout Plain Layout

    resampled_df = df.resample(f'{interval}T').agg({ 'Open': 'first',
\end_layout

\begin_layout Plain Layout

                                                     'High': 'max',
\end_layout

\begin_layout Plain Layout

                                                     'Low': 'min',
\end_layout

\begin_layout Plain Layout

                                                     'Close': 'last',
\end_layout

\begin_layout Plain Layout

                                                     'SMA': 'mean',
\end_layout

\begin_layout Plain Layout

                                                     'EMA': 'mean',
\end_layout

\begin_layout Plain Layout

                                                     'Volume': 'sum'}) 
        
\end_layout

\begin_layout Plain Layout

    return resampled_df
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Retrieves trading data from the Kraken API and stores it in a Pandas DataFrame
 
\end_layout

\begin_layout Plain Layout

@st.cache_data(ttl=300)  # Decorator to cache the data in Streamlit for 5
 minutes 
\end_layout

\begin_layout Plain Layout

def obtain_function(pair, interval, divisor, since, until):
\end_layout

\begin_layout Plain Layout

             
\end_layout

\begin_layout Plain Layout

    # Initializing a Kraken API client and querying data within a try-except
 block     
\end_layout

\begin_layout Plain Layout

    try:         
\end_layout

\begin_layout Plain Layout

        k = krakenex.API()  # Initialize the Kraken client              
    
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        # Query for OHLC data for the specified currency pair, interval
 and start date         
\end_layout

\begin_layout Plain Layout

        response = k.query_public('OHLC',{'pair':pair,'interval':divisor,'since':
since})         
\end_layout

\begin_layout Plain Layout

        if response['error']:  # Check and raise an exception if an error
 is retrieved           
\end_layout

\begin_layout Plain Layout

            print(f"There was an error with the API call")             
\end_layout

\begin_layout Plain Layout

            raise Exception(response['error'])
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    # Catch and print any exceptions during the data retrieval process 
    
\end_layout

\begin_layout Plain Layout

    except Exception as e:         
\end_layout

\begin_layout Plain Layout

        print(f"An error occurred: {e}")      # Print the specific error
 message         
\end_layout

\begin_layout Plain Layout

        print("Error while retrieving data")  # Indicate a data retrieval
 error
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    # Process the retrieved data if no exceptions occur     
\end_layout

\begin_layout Plain Layout

    else:         
\end_layout

\begin_layout Plain Layout

        ohlc_data = response['result'][pair]  # Extract OHLC data from the
 API response
\end_layout

\begin_layout Plain Layout

        
\end_layout

\begin_layout Plain Layout

        # Convert OHLC data to a DataFrame and remove unnecessary columns
         
\end_layout

\begin_layout Plain Layout

        ohlc_df = pd.DataFrame(ohlc_data, columns=["Time", "Open", "High",
 "Low", 
\end_layout

\begin_layout Plain Layout

              "Close", "VWAP", "Volume", "Count"]).drop(['VWAP', 'Count'],
 axis=1)
\end_layout

\begin_layout Plain Layout

        
\end_layout

\begin_layout Plain Layout

        # Convert Unix timestamps to pandas datetime format and set as DataFrame
 index         
\end_layout

\begin_layout Plain Layout

        ohlc_df["Time"] = pd.to_datetime(ohlc_df["Time"], unit='s')     
    
\end_layout

\begin_layout Plain Layout

        ohlc_df.set_index(pd.DatetimeIndex(ohlc_df["Time"]), inplace=True)
         
\end_layout

\begin_layout Plain Layout

        if until is not None:  # Filter data when until is not None    
         
\end_layout

\begin_layout Plain Layout

            cutoff_date = pd.to_datetime(until, unit='s')             
\end_layout

\begin_layout Plain Layout

            ohlc_df = ohlc_df[ohlc_df.index < cutoff_date]
\end_layout

\begin_layout Plain Layout

        
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        # Convert all price and volume data to float type for calculations
         
\end_layout

\begin_layout Plain Layout

        ohlc_df["Open"] = ohlc_df["Open"].astype(float)          
\end_layout

\begin_layout Plain Layout

        ohlc_df["High"] = ohlc_df["High"].astype(float)         
\end_layout

\begin_layout Plain Layout

        ohlc_df["Low"] = ohlc_df["Low"].astype(float)         
\end_layout

\begin_layout Plain Layout

        ohlc_df["Close"] = ohlc_df["Close"].astype(float)        
\end_layout

\begin_layout Plain Layout

        ohlc_df["Volume"] = ohlc_df["Volume"].astype(float)
\end_layout

\begin_layout Plain Layout

        
\end_layout

\begin_layout Plain Layout

        # Add Simple Moving Average (SMA) and Exponential Moving Average
 (EMA)         
\end_layout

\begin_layout Plain Layout

        window = 14 if ohlc_df.shape[0] >= 60 else 3  # Determine window
 size         
\end_layout

\begin_layout Plain Layout

        ohlc_df['SMA'] = ohlc_df['Close'].rolling(window=window).mean()  
       
\end_layout

\begin_layout Plain Layout

        ohlc_df['EMA'] = ohlc_df['Close'].ewm(span=window, adjust=False).mean()
\end_layout

\begin_layout Plain Layout

        
\end_layout

\begin_layout Plain Layout

        # Aggregate data into custom intervals if needed         
\end_layout

\begin_layout Plain Layout

        resampled_df = aggregate_intervals(interval, ohlc_df)         
\end_layout

\begin_layout Plain Layout

        if interval not in (1, 5, 15, 30, 60, 240, 1440, 10080, 21600):
             
\end_layout

\begin_layout Plain Layout

            ohlc_df = resampled_df   
\end_layout

\begin_layout Plain Layout

        
\end_layout

\begin_layout Plain Layout

        window = 14 if ohlc_df.shape[0] >= 60 else 3  # Determine window
 size        
\end_layout

\begin_layout Plain Layout

        ohlc_df['L14'] = ohlc_df['Low'].rolling(window=window).min()     
    
\end_layout

\begin_layout Plain Layout

        ohlc_df['H14'] = ohlc_df['High'].rolling(window=window).max() 
\end_layout

\begin_layout Plain Layout

       
\end_layout

\begin_layout Plain Layout

        ohlc_df['%K'] = (ohlc_df['Close'] - ohlc_df['L14']) / 
\end_layout

\begin_layout Plain Layout

                                      (ohlc_df['H14'] - ohlc_df['L14'])
 * 100        
\end_layout

\begin_layout Plain Layout

        ohlc_df['%D'] = ohlc_df['%K'].rolling(window=3).mean()      
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

        ohlc_df['Buy_Signal'] = ((ohlc_df['%K'] > ohlc_df['%D']) & 
\end_layout

\begin_layout Plain Layout

                                 (ohlc_df['%K'].shift(1) < ohlc_df['%D'].shift(1))
 & 
\end_layout

\begin_layout Plain Layout

                                 (ohlc_df['%D'] < 20))
\end_layout

\begin_layout Plain Layout

        
\end_layout

\begin_layout Plain Layout

        ohlc_df['Sell_Signal'] = ((ohlc_df['%K'] < ohlc_df['%D']) & 
\end_layout

\begin_layout Plain Layout

                                  (ohlc_df['%K'].shift(1) > ohlc_df['%D'].shift(1)
) & 
\end_layout

\begin_layout Plain Layout

                                  (ohlc_df['%D'] > 80))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        return ohlc_df  # Return the prepared DataFrame
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

class Graph: 
\end_layout

\begin_layout Plain Layout

    [...]
\end_layout

\begin_layout Plain Layout

    # Retrieves trading data from the Kraken API and stores it in a Pandas
 DataFrame     
\end_layout

\begin_layout Plain Layout

    def obtain_data(self):         
\end_layout

\begin_layout Plain Layout

        return obtain_function(self.pair, self.interval, 
\end_layout

\begin_layout Plain Layout

                               self.divisor, self.since, self.until)
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout


\backslash
end{python}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Grabado de las cotizaciones
\end_layout

\begin_layout Standard
Las cotizaciones de un par de divisas suelen ser representadas haciendo
 uso de un gráfico de velas para la información OHLC (
\family typewriter
Open
\family default
 - 
\family typewriter
High
\family default
 - 
\family typewriter
Low
\family default
 - 
\family typewriter
Close
\family default
).
 Para llevar a cabo esta representación creamos una figura 
\family typewriter
candlestick
\family default
 con 
\family typewriter
plotly
\family default
, a partir de los datos obtenidos en la consulta a la API de Kraken.
 Adicionalmente, hemos incluido la información del volumen a lo largo del
 tiempo con un diagrama de barras que refleja el cambio en el precio con
 el mismo color que la vela correspondiente pero con una opacidad menor
 para que ambas gráficas puedan coexistir y complementarse.
 Por otro lado, hemos tenido en cuenta la información de cierre para añadir
 diagramas de líneas que representen los indicadores para el SMA y el EMA.
\begin_inset VSpace 12bp
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{python}
\end_layout

\begin_layout Plain Layout

# The class Graph is designed for constructing candlestick and 
\end_layout

\begin_layout Plain Layout

#  stochastic oscillator graphs with moving averages for trading analysis
\end_layout

\begin_layout Plain Layout

class Graph:
\end_layout

\begin_layout Plain Layout

    [...]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    # Static method to create a candlestick chart from OHLC data using Plotly
\end_layout

\begin_layout Plain Layout

    @staticmethod       
\end_layout

\begin_layout Plain Layout

    def candlestick(ohlc_df):
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        try:
\end_layout

\begin_layout Plain Layout

            colors = ['#008080' if close >= open else 'red' for open, close
 
\end_layout

\begin_layout Plain Layout

                                in zip(df['Open'], df['Close'])]
\end_layout

\begin_layout Plain Layout

            
\end_layout

\begin_layout Plain Layout

            fig = make_subplots(specs=[[{"secondary_y": True}]])
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

            # Include candlestick with range selector             
\end_layout

\begin_layout Plain Layout

            fig.add_trace(go.Candlestick(x=df.index, open=df['Open'], high=df['High
'], 
\end_layout

\begin_layout Plain Layout

                          low=df['Low'], close=df['Close'], name='',
\end_layout

\begin_layout Plain Layout

                          legendgroup='group', legendrank=1), secondary_y=True)
\end_layout

\begin_layout Plain Layout

            
\end_layout

\begin_layout Plain Layout

            # Bar diagram displaying the Volume data
\end_layout

\begin_layout Plain Layout

            fig.add_trace(go.Bar(x=df.index, y=df['Volume'], marker_color=colors,
 
\end_layout

\begin_layout Plain Layout

                                    opacity=0.25, showlegend=False), secondary_y=
False)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

            # Line chart displaying the computed SMA values
\end_layout

\begin_layout Plain Layout

            fig.add_trace(go.Scatter(x=df.index, y=df['SMA'], 
\end_layout

\begin_layout Plain Layout

                          marker=dict(color='#0000FF'), opacity=0.35, name='SMA',
\end_layout

\begin_layout Plain Layout

                          legendgroup='group', legendrank=2), secondary_y=True)
 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

            # Line chart displaying the computed EMA values 
\end_layout

\begin_layout Plain Layout

            fig.add_trace(go.Scatter(x=df.index, y=df['EMA'], 
\end_layout

\begin_layout Plain Layout

                          marker=dict(color='#FF0000'), opacity=0.35, name='EMA',
 
\end_layout

\begin_layout Plain Layout

                          legendgroup='group', legendrank=3), secondary_y=True)
      
\end_layout

\begin_layout Plain Layout

                  
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

            fig.layout.yaxis2.showgrid = False             
\end_layout

\begin_layout Plain Layout

            fig.layout.title = 'Candlestick Graph with Volume and Moving Averages'
             
\end_layout

\begin_layout Plain Layout

            fig.layout.height = 400             
\end_layout

\begin_layout Plain Layout

            fig.layout.width = 650
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

            return fig  # Return the Figure object for plotting        
          
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        # Handle exceptions in chart creation and return an empty figure
 in case of error
\end_layout

\begin_layout Plain Layout

        except Exception as e:                          
\end_layout

\begin_layout Plain Layout

            print(f"An error occurred while creating the candlestick chart:
 {e}") 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

            # Return an empty Plotly Figure object if an error occurs
\end_layout

\begin_layout Plain Layout

            return go.Figure() 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{python}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset

El gráfico de velas resultante, con el diagrama de barras para el Volumen
 y los diagramas de líneas para los indicadores SMA y EMA, se vería como
 sigue en la aplicación creada con 
\family typewriter
streamlit
\family default
:
\begin_inset VSpace 10bp
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename candlestick.JPG
	scale 45

\end_inset


\end_layout

\begin_layout Section
Indicadores técnicos
\end_layout

\begin_layout Standard
Como ya hemos explicado en el apartado anterior, se han calculado y representado
 en el gráfico de velas los indicadores SMA (
\shape italic
Simple Moving Average
\shape default
) y EMA (
\shape italic
Exponential Moving Average
\shape default
).
 Sin embargo, el indicador principal de esta práctica ha sido el oscilador
 estocástico, el cual explicaremos a continuación como ha sido calculado
 y su representación gráfica en la aplicación creada (de forma única y en
 combinación con el gráfico de velas).
 El VWAP es otro indicador que podría haberse añadido junto con la representació
n gráfica de la información OHLC gracias a que viene dado directamente por
 la respuesta de la API de Kraken.
\end_layout

\begin_layout Subsection
Cálculo y representación gráfica del oscilador estocástico
\end_layout

\begin_layout Standard
El oscilador estocástico, desarrollado en la década de 1950, es un indicador
 de momentum utilizado en el análisis técnico de los mercados financieros.
 Su función principal es identificar condiciones de sobrecompra o sobreventa
 en el precio de un activo.
 Lo hace mostrando la posición del cierre actual del mercado en relación
 con el rango de precios durante un período específico, comúnmente 14 intervalos.
 Un valor alto indica que el precio está cerrando cerca del máximo reciente
 y un valor bajo, un cierre cercano al mínimo reciente.
 
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
La fórmula para calcular el oscilador estocástico es la siguiente:
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\%K_{i,range}=\frac{Close_{i}-\min(Low_{range})}{\max(High_{range})-\min(Low_{range})}\times100
\]

\end_inset

donde:
\end_layout

\begin_layout Itemize
\begin_inset Formula $Close_{i}$
\end_inset

 es el último precio al que se negoció un activo en el intervalo 
\begin_inset Formula $i$
\end_inset

, 
\end_layout

\begin_layout Itemize
\begin_inset Formula $\min(Low_{range})$
\end_inset

 es el precio más bajo negociado del activo durante un período 
\begin_inset Formula $range$
\end_inset

 determinado,
\end_layout

\begin_layout Itemize
\begin_inset Formula $\max(High_{range})$
\end_inset

 es el precio más alto negociado del activo durante un período 
\begin_inset Formula $range$
\end_inset

 determinado.
 
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Normalmente, el oscilador estocástico se muestra con una media móvil 
\begin_inset Formula $\%D$
\end_inset

.
 Habitualmente, la línea 
\begin_inset Formula $\%K$
\end_inset

 se calcula utilizando un período estándar de 14 intervalos, reflejando
 el nivel actual de precio en relación con los rangos de precios altos y
 bajos durante este período.
 La línea 
\begin_inset Formula $\%D$
\end_inset

, por otro lado, es una media móvil de la línea 
\begin_inset Formula $\%K$
\end_inset

, y típicamente se calcula sobre un periodo de 3 intervalos, lo que ayuda
 a suavizar las fluctuaciones de 
\begin_inset Formula $\%K$
\end_inset

 y proporciona una mejor perspectiva de la tendencia general.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
En nuestra metodología, hemos adoptado estas convenciones: utilizamos 14
 intervalos para calcular la línea 
\begin_inset Formula $\%K$
\end_inset

 y 3 intervalos para la línea 
\begin_inset Formula $\%D$
\end_inset

.
 Sin embargo, también hemos incorporado un ajuste importante en situaciones
 donde el total de intervalos disponibles es menor a 60.
 En tales casos, reducimos el período de cálculo para la línea 
\begin_inset Formula $\%K$
\end_inset

 a 3 intervalos.
 Gracias a esta modificación, nos aseguramos de que los indicadores calculados
 tengan la mayor relevancia y precisión posibles en escenarios con menos
 datos.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{python}
\end_layout

\begin_layout Plain Layout

# Retrieves trading data from the Kraken API and stores it in a Pandas DataFrame
 
\end_layout

\begin_layout Plain Layout

@st.cache_data(ttl=300)  # Decorator to cache the data in Streamlit for 5
 minutes 
\end_layout

\begin_layout Plain Layout

def obtain_function(pair, interval, divisor, since, until):
\end_layout

\begin_layout Plain Layout

    [...]
\end_layout

\begin_layout Plain Layout

    window = 14 if ohlc_df.shape[0]>=60 else 3         
\end_layout

\begin_layout Plain Layout

    ohlc_df['L14'] = ohlc_df['Low'].rolling(window=window).min()         
\end_layout

\begin_layout Plain Layout

    ohlc_df['H14'] = ohlc_df['High'].rolling(window=window).max()        
 
\end_layout

\begin_layout Plain Layout

    ohlc_df['%K'] = (ohlc_df['Close'] - ohlc_df['L14']) / 
\end_layout

\begin_layout Plain Layout

                      (ohlc_df['H14'] - ohlc_df['L14']) * 100         
\end_layout

\begin_layout Plain Layout

    ohlc_df['%D'] = ohlc_df['%K'].rolling(window=3).mean()
\end_layout

\begin_layout Plain Layout

    [...]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

class Graph:
\end_layout

\begin_layout Plain Layout

    [...]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    @staticmethod  # Calculate and graph the stochastic oscillator and its
 mobile mean      
\end_layout

\begin_layout Plain Layout

    def stochastic(df): 
\end_layout

\begin_layout Plain Layout

 
\end_layout

\begin_layout Plain Layout

        try:             
\end_layout

\begin_layout Plain Layout

            data = [# Line chart for the '%D' line of the stochastic oscillator
                     
\end_layout

\begin_layout Plain Layout

                   go.Scatter(x=df.index, y=df['%D'], name='Smoothed Stochastic',
 
\end_layout

\begin_layout Plain Layout

                              marker=dict(color='#b2b2b2'), 
\end_layout

\begin_layout Plain Layout

                              legendgroup='group', legendrank=5),
\end_layout

\begin_layout Plain Layout

                                         
\end_layout

\begin_layout Plain Layout

                    # Line chart for the '%K' line of the stochastic oscillator
                     
\end_layout

\begin_layout Plain Layout

                    go.Scatter(x=df.index, y=df['%K'], name='Stochastic Oscillator
', 
\end_layout

\begin_layout Plain Layout

                               marker=dict(color='#4c4c4c'), 
\end_layout

\begin_layout Plain Layout

                               legendgroup='group', legendrank=4),
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

                    # Horizontal line at 20%                     
\end_layout

\begin_layout Plain Layout

                    go.Scatter(x=df.index, y=[20]*len(df.index), mode='lines',
 
\end_layout

\begin_layout Plain Layout

                               name='20% threshold', line=dict(color='purple',
 
\end_layout

\begin_layout Plain Layout

                               width=1, dash='dash'), showlegend=False),
\end_layout

\begin_layout Plain Layout

                    
\end_layout

\begin_layout Plain Layout

                    # Horizontal line at 80%                     
\end_layout

\begin_layout Plain Layout

                    go.Scatter(x=df.index, y=[80]*len(df.index), mode='lines',
 
\end_layout

\begin_layout Plain Layout

                               name='80% threshold', line=dict(color='purple',
 
\end_layout

\begin_layout Plain Layout

                               width=1, dash='dash'), showlegend=False)]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

            # Define the layout for the plotly figure, setting titles and
 axis labels             
\end_layout

\begin_layout Plain Layout

            layout = go.Layout(title='Stochastic Oscillator with its Smoothed
 Version',
\end_layout

\begin_layout Plain Layout

                               yaxis=dict(title='Value (%)', range=[0,100]))
  
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

            # Create a Figure object with the candlestick data
\end_layout

\begin_layout Plain Layout

            fig = go.Figure(data=data, layout=layout)               
\end_layout

\begin_layout Plain Layout

            fig.layout.height = 250             
\end_layout

\begin_layout Plain Layout

            return fig  # Return the Figure object for plotting
\end_layout

\begin_layout Plain Layout

        
\end_layout

\begin_layout Plain Layout

        # Handle exceptions in chart creation and return an empty figure
 in case of error         
\end_layout

\begin_layout Plain Layout

        except Exception as e:             
\end_layout

\begin_layout Plain Layout

            print(f"An error occurred while creating the candlestick chart:
 {e}")             
\end_layout

\begin_layout Plain Layout

            return go.Figure()  # Return an empty Plotly Figure object if
 an error occurs
\end_layout

\begin_layout Plain Layout


\backslash
end{python}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace 16bp
\end_inset

El gráfico para el oscilador estocástico y su media móvil, se verían como
 sigue en la aplicación de 
\family typewriter
streamlit
\family default
:
\begin_inset VSpace 16bp
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename stochastic.JPG
	scale 45

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace 25bp
\end_inset

Los indicadores %K y %D pueden utilizarse para seguir la siguiente estrategia
 de trading: cuando 
\begin_inset Formula $\%K$
\end_inset

 cruza por encima a 
\begin_inset Formula $\%D$
\end_inset

 y 
\begin_inset Formula $\%D$
\end_inset

 es inferior al 20% se genera una señal de compra, mientras que cuando 
\begin_inset Formula $\%K$
\end_inset

 cruza por debajo a 
\begin_inset Formula $\%D$
\end_inset

 y la línea 
\begin_inset Formula $\%D$
\end_inset

 es superior al 80% se genera una señal de venta.
 Esta estrategia ha sido implementada en nuestra aplicación para poder observar
 el rendimiento que se tiene al seguir este enfoque.
 
\begin_inset VSpace 20bp
\end_inset


\end_layout

\begin_layout Standard
Para ello, hemos usado las señales de compra para simular una cartera en
 la que se compran 100 unidades de la moneda por señal y vendemos 100 unidades
 por cada señal de venta (siempre que la cartera cuente con dicha cantidad).
 La gráfica generada representa las ganancias o pérdidas que se tendrian
 a lo largo del periodo graficado.
 Si no se han generado señales de compra en el periodo, no se muestra ninguna
 grafica.
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{python}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

class Graph:
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    [...]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    # Function to calculate the profit from trading based on buy and sell
 signals     
\end_layout

\begin_layout Plain Layout

    def calculate_profit(self, df): 
\end_layout

\begin_layout Plain Layout

       
\end_layout

\begin_layout Plain Layout

        try: 
\end_layout

\begin_layout Plain Layout

           
\end_layout

\begin_layout Plain Layout

            # Initialize variables to track coins held and total amount
 spent             
\end_layout

\begin_layout Plain Layout

            coins = 0             
\end_layout

\begin_layout Plain Layout

            total_spent = 0
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

            # Buy_Price is set to the Close price where Buy_Signal==True,
 otherwise NaN             
\end_layout

\begin_layout Plain Layout

            df['Buy_Price'] = np.where(df['Buy_Signal'], df['Close'], np.nan)
\end_layout

\begin_layout Plain Layout

            
\end_layout

\begin_layout Plain Layout

            # Sell_Price is set to the Close price where Sell_Signal==True,
 otherwise NaN             
\end_layout

\begin_layout Plain Layout

            df['Sell_Price'] = np.where(df['Sell_Signal'], df['Close'], np.nan)
             
\end_layout

\begin_layout Plain Layout

            df['Profit'] = 0
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

            # Loop through each row in the DataFrame             
\end_layout

\begin_layout Plain Layout

            for i in range(len(df)): 
\end_layout

\begin_layout Plain Layout

               
\end_layout

\begin_layout Plain Layout

                # If there's a buy signal, increase coins and add to total
 spent                 
\end_layout

\begin_layout Plain Layout

                if df['Buy_Signal'].iloc[i]:                     
\end_layout

\begin_layout Plain Layout

                    coins += 100                     
\end_layout

\begin_layout Plain Layout

                    total_spent += df['Buy_Price'].iloc[i] * 100
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

                # If there's a sell signal and enough coins are held, 
\end_layout

\begin_layout Plain Layout

                #  reduce coins and subtract from total spent          
       
\end_layout

\begin_layout Plain Layout

                if df['Sell_Signal'].iloc[i] and coins >= 100:          
           
\end_layout

\begin_layout Plain Layout

                    coins -= 100                     
\end_layout

\begin_layout Plain Layout

                    total_spent -= df['Sell_Price'].iloc[i] * 100
\end_layout

\begin_layout Plain Layout

                
\end_layout

\begin_layout Plain Layout

                # Calculate profit: current value of held coins minus total
 amount spent                 
\end_layout

\begin_layout Plain Layout

                df.loc[df.index[i], 'Profit'] = (df.loc[df.index[i], 'Close']
 * coins) - 
\end_layout

\begin_layout Plain Layout

                                                total_spent
\end_layout

\begin_layout Plain Layout

            
\end_layout

\begin_layout Plain Layout

            return df  # Return the modified DataFrame with the 'Profit'
 column
\end_layout

\begin_layout Plain Layout

        
\end_layout

\begin_layout Plain Layout

        # Catching and printing any exceptions that occur during the function
 execution         
\end_layout

\begin_layout Plain Layout

        except Exception as e:             
\end_layout

\begin_layout Plain Layout

            print(f"An error occurred while creating the profit data: {e}")
\end_layout

\begin_layout Plain Layout

            
\end_layout

\begin_layout Plain Layout

            # Returning an empty DataFrame in case of an exception     
        
\end_layout

\begin_layout Plain Layout

            return pd.DataFrame()
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    # Function to create a profit graph from a DataFrame containing buy
 and sell signals     
\end_layout

\begin_layout Plain Layout

    def profit_graph(self, df): 
\end_layout

\begin_layout Plain Layout

       
\end_layout

\begin_layout Plain Layout

        try:            
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

            # Check if there are any buy signals in the DataFrame      
       
\end_layout

\begin_layout Plain Layout

            if not df['Buy_Signal'].any():                 
\end_layout

\begin_layout Plain Layout

                return None  # Return None if there are no buy signals 
                        
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

            # Get the index of the first buy signal in the DataFrame
\end_layout

\begin_layout Plain Layout

            first_buy_signal = df[df['Buy_Signal']].index[0]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

            # Slice the DataFrame from the first buy signal onwards
\end_layout

\begin_layout Plain Layout

            df = df.loc[first_buy_signal:]                    
\end_layout

\begin_layout Plain Layout

            
\end_layout

\begin_layout Plain Layout

            # Create a list of Scatter plots for the profit graph      
       
\end_layout

\begin_layout Plain Layout

            data = [                 
\end_layout

\begin_layout Plain Layout

                    # Line plot for cumulative profit over time        
         
\end_layout

\begin_layout Plain Layout

                    go.Scatter(x=df.index, y=df['Profit'].cumsum(), name='Profit',
 
\end_layout

\begin_layout Plain Layout

                               marker=dict(color='#0d0c52')),
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

                    # Marker plot for points where buy signals occur   
              
\end_layout

\begin_layout Plain Layout

                    go.Scatter(x=df[df['Buy_Signal']].index, 
\end_layout

\begin_layout Plain Layout

                               y=df['Profit'].cumsum()[df['Buy_Signal']],
 
\end_layout

\begin_layout Plain Layout

                               mode='markers', marker=dict(color='#05e3a0',
 
\end_layout

\begin_layout Plain Layout

                               size=10), name='Buy Signal'),
\end_layout

\begin_layout Plain Layout

                
\end_layout

\begin_layout Plain Layout

                    # Marker plot for points where sell signals occur  
               
\end_layout

\begin_layout Plain Layout

                    go.Scatter(x=df[df['Sell_Signal']].index, 
\end_layout

\begin_layout Plain Layout

                               y=df['Profit'].cumsum()[df['Sell_Signal']],
 
\end_layout

\begin_layout Plain Layout

                               mode='markers', marker=dict(color='#f77088',
 
\end_layout

\begin_layout Plain Layout

                               size=10), name='Sell Signal')           
          
\end_layout

\begin_layout Plain Layout

            ]                          
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

            # Define the layout for the graph, including axis labels and
 margins             
\end_layout

\begin_layout Plain Layout

            layout = go.Layout(                 
\end_layout

\begin_layout Plain Layout

                yaxis=dict(title='Value'),           
\end_layout

\begin_layout Plain Layout

                margin=dict(l=40, r=40, t=20, b=40))
\end_layout

\begin_layout Plain Layout

            
\end_layout

\begin_layout Plain Layout

            # Create a Figure object with the defined data and layout  
           
\end_layout

\begin_layout Plain Layout

            fig = go.Figure(data=data, layout=layout)
\end_layout

\begin_layout Plain Layout

            
\end_layout

\begin_layout Plain Layout

            # Set the height and width of the figure             
\end_layout

\begin_layout Plain Layout

            fig.layout.height = 350             
\end_layout

\begin_layout Plain Layout

            fig.layout.width = 650             
\end_layout

\begin_layout Plain Layout

            return fig  # Return the Figure object for plotting
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        # Print an error message if an exception occurs and return an empty
 Figure object         
\end_layout

\begin_layout Plain Layout

        except Exception as e:             
\end_layout

\begin_layout Plain Layout

            print(f"An error occurred while creating the profit chart: {e}")
             
\end_layout

\begin_layout Plain Layout

            return go.Figure()
\end_layout

\begin_layout Plain Layout


\backslash
end{python}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
El gráfico de la evolución del beneficio obtenido, se vería como sigue en
 la aplicación de 
\family typewriter
streamlit
\family default
:
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename profit.JPG
	scale 50

\end_inset


\begin_inset VSpace 5bp
\end_inset


\end_layout

\begin_layout Subsection
Cálculo del oscilador estocástico sobre una media móvil
\end_layout

\begin_layout Standard
Como hemos expuesto en el apartado anterior, la media móvil 
\begin_inset Formula $\%D$
\end_inset

 se utiliza para suavizar las fluctuaciones de 
\begin_inset Formula $\%K$
\end_inset

 y para la generación de señales de compra y venta en la estrategia descrita.
 Otro enfoque para calcular un oscilador estocástico suavizado sería sustituir,
 en la propia fórmula de su definición, el precio de cierre de un intervalo
 con la media móvil del cierre (esto sería el SMA).
 Esta posibilidad sería de fácil implementación en nuestro código, pues
 ya contamos con un campo para este indicador y la sustitución sería directa.
 Así se vería el fragmento de código modificado:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{python}
\end_layout

\begin_layout Plain Layout

#código
\end_layout

\begin_layout Plain Layout


\backslash
end{python}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Gráfico del indicador junto con la cotización del par calculado
\end_layout

\begin_layout Standard
Finalmente, damos al usuario la opción de graficar tanto la cotización (junto
 con el volumen, SMA y EMA) como el oscilador estocástico 
\begin_inset Formula $\%K$
\end_inset

 y su media móvil 
\begin_inset Formula $\%D$
\end_inset

, en una única figura.
 Para ello, combinamos adecuadamente los gráficos generados por separado
 y creamos un menú para seleccionar la gráfica que se desea visualizar.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{python}
\end_layout

\begin_layout Plain Layout

#código
\end_layout

\begin_layout Plain Layout


\backslash
end{python}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{python}
\end_layout

\begin_layout Plain Layout

#captura
\end_layout

\begin_layout Plain Layout


\backslash
end{python}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Estructuración
\end_layout

\begin_layout Subsection
Funciones
\end_layout

\begin_layout Standard
El proyecto se estructura en varios módulos y clases para facilitar la organizac
ión y la reutilización del código.
\end_layout

\begin_layout Standard
El módulo principal del proyecto es main.py, que importa y utiliza las funciones
 y clases definidas en otros módulos.
\end_layout

\begin_layout Standard
Los módulos adicionales incluyen 
\begin_inset ERT
status open

\begin_layout Plain Layout

graphs.py
\end_layout

\end_inset

 y 
\begin_inset ERT
status open

\begin_layout Plain Layout

front.py
\end_layout

\end_inset


\end_layout

\begin_layout Standard
- 
\begin_inset ERT
status open

\begin_layout Plain Layout

graphs.py
\end_layout

\end_inset

 contiene la clase Graph que se encarga de crear gráficos de velas y osciladores
 estocásticos para el análisis de trading.
\end_layout

\begin_layout Standard
- 
\begin_inset ERT
status open

\begin_layout Plain Layout

front.py
\end_layout

\end_inset

 contiene la clase Front que se encarga de manejar la interfaz de usuario
 de la aplicación.
\end_layout

\begin_layout Standard
Además, el proyecto incluye un archivo README.md que proporciona una descripción
 general del proyecto y las instrucciones para su uso.
 También se incluye una carpeta docs que contiene varios archivos de texto
 que proporcionan más detalles sobre el proyecto y sus requisitos.
\end_layout

\begin_layout Subsection
Utilización de clases
\end_layout

\begin_layout Subsection
Manejo de errores y excepciones
\end_layout

\begin_layout Standard
El manejo de excepciones en este proyecto se realiza principalmente a través
 de la estructura de control de flujo 
\begin_inset ERT
status open

\begin_layout Plain Layout

try/except
\end_layout

\end_inset

.
 Esta estructura permite capturar y manejar errores que pueden ocurrir durante
 la ejecución del programa.
\end_layout

\begin_layout Standard
Por ejemplo en el metodo que genera la grafica de beneficios, en caso de
 encontrar un error imprime un mensaje por consola y retorna una figura
 vacia.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{python}
\end_layout

\begin_layout Plain Layout

   def profit_graph(self, df):
\end_layout

\begin_layout Plain Layout

     try:
\end_layout

\begin_layout Plain Layout

         [...]
\end_layout

\begin_layout Plain Layout

         fig = go.Figure(data=data, layout=layout)  # create a Figure object
 with the profit data
\end_layout

\begin_layout Plain Layout

         return fig  # return the Figure object for plotting         
\end_layout

\begin_layout Plain Layout

     except Exception as e:
\end_layout

\begin_layout Plain Layout

        print(f"An error occurred while creating the profit chart: {e}")
\end_layout

\begin_layout Plain Layout

        return go.Figure()
\end_layout

\begin_layout Plain Layout


\backslash
end{python}
\end_layout

\end_inset

En esta ocasión por ejemplo imprimimos un mensaje de error directamente
 en la aplicación.
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{python}
\end_layout

\begin_layout Plain Layout

   # Method to execute the core operations of the Streamlit application
     
\end_layout

\begin_layout Plain Layout

   def run(self):
\end_layout

\begin_layout Plain Layout

     try:
\end_layout

\begin_layout Plain Layout

       [...]
\end_layout

\begin_layout Plain Layout

     except Exception as e:
\end_layout

\begin_layout Plain Layout

       # Handle and display any exceptions that occur during execution
\end_layout

\begin_layout Plain Layout

       st.error(f"An error occurred: {e}")  # Show the error message to the
 user in the app
\end_layout

\begin_layout Plain Layout


\backslash
end{python}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Puntuación Extra
\end_layout

\begin_layout Subsection
Testeo y cobertura (unit-testing, integration-testing)
\end_layout

\begin_layout Standard
Hemos gestionado los unit-test e integration tests con la libreria 
\begin_inset ERT
status open

\begin_layout Plain Layout

unittest
\end_layout

\end_inset

.
 Este módulo permite definir clases de prueba con métodos que representan
 pruebas individuales.
 Aquí vemos un ejemplo de los tests que hemos añadido al proyecto.
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{python}
\end_layout

\begin_layout Plain Layout

# Test method to test the get_kraken_pairs function
\end_layout

\begin_layout Plain Layout

    def test_get_kraken_pairs(self):
\end_layout

\begin_layout Plain Layout

        result = get_kraken_pairs()  # Calling the get_kraken_pairs function
 and storing its result
\end_layout

\begin_layout Plain Layout

        # Checking if the result is a tuple and has a length greater than
 0
\end_layout

\begin_layout Plain Layout

        self.assertIsInstance(result, tuple)
\end_layout

\begin_layout Plain Layout

        self.assertTrue(len(result) > 0)
\end_layout

\begin_layout Plain Layout


\backslash
end{python}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename test_result.png

\end_inset


\end_layout

\begin_layout Subsection
Facilitar los mecanismos para la reproducción del entorno virtual
\end_layout

\begin_layout Enumerate
Para añadir Poetry al proyecto, se ha utilizado el archivo pyproject.toml
 que se encuentra en la raíz del proyecto.
 Este archivo es utilizado por Poetry para manejar las dependencias del
 proyecto.
 En este archivo se especifican las dependencias del proyecto, la versión
 de Python requerida y otros metadatos del proyecto.
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{python}
\end_layout

\begin_layout Plain Layout

[tool.poetry]
\end_layout

\begin_layout Plain Layout

name = "krakenpythonmarcosrodrigo"
\end_layout

\begin_layout Plain Layout

version = "0.1.2"
\end_layout

\begin_layout Plain Layout

description = "A streamlit tool for rendering kraken data"
\end_layout

\begin_layout Plain Layout

authors = ["Your Name <you@example.com>"]
\end_layout

\begin_layout Plain Layout

readme = "README.md"
\end_layout

\begin_layout Plain Layout

[tool.poetry.dependencies]
\end_layout

\begin_layout Plain Layout

python = "^3.11"
\end_layout

\begin_layout Plain Layout

plotly = "4.14.3"
\end_layout

\begin_layout Plain Layout

streamlit = "0.79.0"
\end_layout

\begin_layout Plain Layout

coverage = "5.5"
\end_layout

\begin_layout Plain Layout

pandas = "2.1.4"
\end_layout

\begin_layout Plain Layout

numpy = "1.26.2"
\end_layout

\begin_layout Plain Layout

krakenex = "2.1.0"
\end_layout

\begin_layout Plain Layout

streamlit-option-menu = "0.3.6"
\end_layout

\begin_layout Plain Layout

[build-system]
\end_layout

\begin_layout Plain Layout

requires = ["poetry-core"]
\end_layout

\begin_layout Plain Layout

build-backend = "poetry.core.masonry.api"
\end_layout

\begin_layout Plain Layout


\backslash
end{python}
\end_layout

\end_inset

Para reproducir el entorno virtual utilizando Poetry, se deben seguir los
 siguientes pasos:
\end_layout

\begin_deeper
\begin_layout Standard
1.
 Instalar Poetry.
 Puedes hacerlo siguiendo las instrucciones en la documentación oficial
 de Poetry.
\end_layout

\begin_layout Standard
2.
 Clonar el repositorio del proyecto.
\end_layout

\begin_layout Standard
3.
 Navegar hasta el directorio del proyecto.
\end_layout

\begin_layout Standard
4.
 Ejecutar el comando 
\begin_inset ERT
status open

\begin_layout Plain Layout

poetry install
\end_layout

\end_inset

 Este comando instalará todas las dependencias especificadas en el archivo
 
\begin_inset ERT
status open

\begin_layout Plain Layout

pyproject.toml
\end_layout

\end_inset


\end_layout

\begin_layout Standard
5.
 Para activar el entorno virtual creado por Poetry, ejecuta el comando poetry
 shell.
 
\end_layout

\end_deeper
\begin_layout Subsection
Distribución del proyecto a través de PyPi
\end_layout

\begin_layout Standard
Primero se han instalado las dependencias de desarrollo Hatch y Twine
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
pythoninline{$pip install hatch}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
pythoninline{$pip install pip twine}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
2.
 Crear una cuenta en PyPI, adicionalmente se necesitara activar la autenticación
 de doble factor y se debe utilizar la token de la API en Twine
\end_layout

\begin_layout Standard
3.
 Para crear el distribuible: 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
pythoninline{$hatch build}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
4.
 Para publicar el paquete:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
pythoninline{$twine upload dist/*}
\end_layout

\end_inset

(con tu cuenta de pypi)
\end_layout

\begin_layout Standard
5.
 Una vez que tu paquete esté publicado en PyPI, otros pueden instalarlo
 utilizando 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
pythoninline{$pip install} 
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Distribución del proyecto a través de DockerHub
\end_layout

\begin_layout Standard
Para crear la imagen que se ha subido a DockerHub se han seguido los siguientes
 pasos:
\end_layout

\begin_layout Enumerate
Creado un Dockerfile que describa el contenedor:
\end_layout

\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{python}
\end_layout

\begin_layout Plain Layout

# Use an official Python runtime as a parent image 
\end_layout

\begin_layout Plain Layout

FROM python:3.11-slim-buster
\end_layout

\begin_layout Plain Layout

# Set the working directory in the container to /app 
\end_layout

\begin_layout Plain Layout

WORKDIR /app
\end_layout

\begin_layout Plain Layout

# Add the current directory contents into the container at /app 
\end_layout

\begin_layout Plain Layout

ADD .
 /app
\end_layout

\begin_layout Plain Layout

# Install Poetry 
\end_layout

\begin_layout Plain Layout

RUN pip install poetry
\end_layout

\begin_layout Plain Layout

# Use Poetry to install dependencies 
\end_layout

\begin_layout Plain Layout

RUN poetry install
\end_layout

\begin_layout Plain Layout

# Make port 8501 available to the world outside this container 
\end_layout

\begin_layout Plain Layout

EXPOSE 8501
\end_layout

\begin_layout Plain Layout

# Run main.py when the container launches 
\end_layout

\begin_layout Plain Layout

CMD ["poetry", "run", "streamlit", "run", "main.py"]
\end_layout

\begin_layout Plain Layout


\backslash
end{python}
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
Construimos la imagen de Docker con:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
pythoninline{$docker build -t dixrow/krakenpythonmarcosrodrigo .}
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Creamos una cuenta de Docker y la enlazamos con:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
pythoninline{$docker login}
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Subimos la imagen que hemos creado con:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
pythoninline{$docker push dixrow/krakenpythonmarcosrodrigo:latest}
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Para bajarse la imagen de DockerHub:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
pythoninline{$docker pull dixrow/krakenpythonmarcosrodrigo}
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Para ejecutar la imagen:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
pythoninline{$docker run -p 8501:8501 dixrow/krakenpythonmarcosrodrigo}
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Por último puedes acceder a través del navegador con el enlace: 
\begin_inset ERT
status open

\begin_layout Plain Layout

127.0.0.1:8501
\end_layout

\end_inset


\end_layout

\end_body
\end_document
